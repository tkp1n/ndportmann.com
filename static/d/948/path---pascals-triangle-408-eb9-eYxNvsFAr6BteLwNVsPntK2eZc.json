{"data":{"post":{"id":"02a0c736-732d-5ec7-802c-c7b40700924f","html":"<p>As part of a recent job interview process, I was asked to submit an implementation of Pascal’s triangle in Scala. Pascal’s triangle is an excellent programming assignment as there is an almost endless amount of possible solutions. It is not particularly hard to solve, but how you solve it tells much about you as a software engineer.</p>\n<div class=\"gatsby-highlight\" data-language=\"1\"><pre class=\"language-1\"><code class=\"language-1\">   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n\n&gt; ... Each entry of each subsequent row is constructed by adding the number above and to the left with the number above and to the right, treating blank entries as 0. ... - Wikipedia\n\nI decided to set the following focus in my implementation:\n\n- Concieness\n- Simplicity\n- Turning edge cases into normal cases\n- Core logic as a one-liner\n\nTo achieve the above I accepted to neglect the following aspects:\n\n- input validation\n- performance\n- pretty printing\n\nBut talk is cheap, so without furhter ado, my solution.\n\n```scala\nobject Pascal {\n  def main(args: Array[String]): Unit = {\n    val rows = args(0).toInt\n\n    (1 until rows)\n      .scanLeft(Seq(1)) { (acc, _) =&gt; calculateRow(acc) }\n      .map(x =&gt; x.mkString(&quot; &quot;))\n      .foreach(println)\n  }\n\n  private def calculateRow(previous: Seq[Int]): Seq[Int] =\n    (0 +: previous :+ 0).sliding(2).map(l =&gt; l.head + l(1)).toSeq\n}</code></pre></div>\n<p>I managed to get the core logic (transforming a given row into the next one) down to one line: <code class=\"language-text\">claculateRow</code>. Central to the approach is Scalas <code class=\"language-text\">sliding</code> function, which allows me to process the previous row using a sliding window of N (N=2 in this case) elements. </p>","fields":{"slug":"/pascals-triangle/","prefix":"2019-02-15"},"frontmatter":{"title":"Pascal's triangle","author":"nicolas portmann","category":"scala","cover":{"childImageSharp":{"resize":{"src":"/static/45a8e06db2a0784be22b65ed39c2176b/ada8c/anton-kraev-1165305-unsplash.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/pascals-triangle/","prev":{"id":"7689cce5-e086-5fe2-a5f6-0c93165d7463","fields":{"slug":"/system-runtime-compilerservices-unsafe/","prefix":"2019-01-27","source":"posts"},"frontmatter":{"title":"Unsafe array access and pointer arithmetics in C#","category":"dotnet"}},"source":"posts"}}