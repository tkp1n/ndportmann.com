{"data":{"post":{"id":"4f7efefe-ed6d-5787-bc07-289eb60587cf","html":"<p>In the first part, we investigated how context information such as MDCs can be passed from and to a Spring WebFlux application. We shall now investigate how we can enrich said context and include it in our log messages.</p>\n<h2>Adding to the Context</h2>\n<p>To add context information to the <code>Context</code>, we use the method <code>subscriberContext</code> present on all <code>Mono</code> and <code>Flux</code> instances. It accepts a <code>Function&#x3C;Context, Context></code> which transforms the exisiting immutable <code>Context</code> into a new <code>Context</code>. In this case with an additional information.</p>\n<pre><code class=\"language-java\">public Mono&#x3C;String> processRequestForClient(String clientId) {\n    return Mono.from(clientId)\n            .map(id -> processRequest(id))\n            .subscriberContext(put(\"CLIENT-ID\", clientId));\n}\n</code></pre>\n<p>The helper function <code>put</code> below provides the required <code>Function&#x3C;Context, Context></code> that adds the given key and value to the context or creates a new context if none exists.</p>\n<pre><code class=\"language-java\">private static final String CONTEXT_MAP = \"context-map\";\n\npublic static Function&#x3C;Context, Context> put(String key, String value) {\n    return ctx -> {\n        Optional&#x3C;Map&#x3C;String, String>> maybeContextMap =\n                ctx.getOrEmpty(CONTEXT_MAP);\n\n        if (maybeContextMap.isPresent()) {\n            maybeContextMap.get().put(key, value);\n            return ctx;\n        } else {\n            Map&#x3C;String, String> ctxMap = new HashMap&#x3C;>();\n            ctxMap.put(key, value);\n\n            return ctx.put(CONTEXT_MAP, ctxMap);\n        }\n    };\n}\n</code></pre>\n<p>Above usage of <code>subscriberContext</code> seems odd, as the addition to the context appears to be the last operation in the chain of calls. The <a href=\"https://projectreactor.io/docs/core/release/reference/#_simple_examples\">Reactor documentation</a> sheds some light on this oddity:</p>\n<blockquote>\n<p>Even though subscriberContext is the last piece of the chain, it is the one that gets executed first (due to its subscription time nature, and the fact that the subscription signal flows from bottom to top).</p>\n</blockquote>\n<h2>Logging with context</h2>\n<p>Time for the final piece of the puzzle; writing logs with set context applied. Just as with the <a href=\"https://simonbasle.github.io/2018/02/contextual-logging-with-reactor-context-and-mdc/\">approach suggested by Simon Basle</a> (mentioned in the previous post), we utilize <code>doOnEach</code> with two helper methods to log with context. The helper methods, in this case, are <code>logOnNext</code> and <code>logOnError</code>. Both invoke a lambda that accepts the current result or the exception respectively. We could therefore add the following two log statemets to the <code>processRequestForClient</code> method from above.</p>\n<pre><code class=\"language-java\">@Service\npublic class FooService {\n    private static final Logger logger \n        = LoggerFactory.getLogger(FooService.class);\n\n    public Mono&#x3C;String> processRequestForClient(String clientId) {\n        return Mono.just(clientId)\n                .flatMap(id -> processRequest(id))\n                .doOnEach(logOnNext(\n                        res -> logger.info(\"Result: {}\", res))\n                ).doOnEach(logOnError(\n                        e -> logger.warn(\"An error occurred...\", e))\n                ).subscriberContext(put(\"CLIENT-ID\", clientId));\n    }\n}\n</code></pre>\n<p>The helper methods <code>logOnNext</code> and <code>logOnError</code> are best placed in a helper class. Both extract the context information from the <code>doOnEach</code> <code>Signal</code> and put set it as the MDC before calling the provided lambda.</p>\n<pre><code class=\"language-java\">public final class LogHelper {\n    public static &#x3C;T> Consumer&#x3C;Signal&#x3C;T>> logOnNext(\n            Consumer&#x3C;T> log) {\n        return signal -> {\n            if (signal.getType() != SignalType.ON_NEXT) return;\n\n            Optional&#x3C;Map&#x3C;String, String>> maybeContextMap\n                    = signal.getContext().getOrEmpty(CONTEXT_MAP);\n\n            if (maybeContextMap.isEmpty()) {\n                log.accept(signal.get());\n            } else {\n                MDC.setContextMap(maybeContextMap.get());\n                try {\n                    log.accept(signal.get());\n                } finally {\n                    MDC.clear();\n                }\n            }\n        };\n    }\n\n    public static &#x3C;T> Consumer&#x3C;Signal&#x3C;T>> logOnError(\n            Consumer&#x3C;Throwable> log) {\n        return signal -> {\n            if (!signal.isOnError()) return;\n\n            Optional&#x3C;Map&#x3C;String, String>> maybeContextMap\n                    = signal.getContext().getOrEmpty(CONTEXT_MAP);\n\n            if (maybeContextMap.isEmpty()) {\n                log.accept(signal.getThrowable());\n            } else {\n                MDC.setContextMap(maybeContextMap.get());\n                try {\n                    log.accept(signal.getThrowable());\n                } finally {\n                    MDC.clear();\n                }\n            }\n        };\n    }\n}\n</code></pre>\n<h2>Summary</h2>\n<p>If we extend our <code>DemoController</code> from part one with a call to above <code>FooService</code>, we are now able to perform the following request:</p>\n<pre><code class=\"language-java\">@PostMapping(\"/demo/{clientId}\")\npublic Mono&#x3C;String> clientDemo(@PathVariable String clientId) {\n    return fooService.processRequestForClient(clientId);\n}\n</code></pre>\n<pre><code class=\"language-bash\">$ curl -v -X POST -H \"X-MDC-FOO: BAR\" localhost:8080/demo/123\n> POST /demo/123 HTTP/1.1\n> Host: localhost:8080\n> User-Agent: curl/7.58.0\n> Accept: */*\n> X-MDC-FOO: BAR\n>\n&#x3C; HTTP/1.1 200 OK\n&#x3C; Content-Type: text/plain;charset=UTF-8\n&#x3C; Content-Length: 2\n&#x3C; X-MDC-CLIENT-ID: 123\n&#x3C; X-MDC-FOO: BAR\n&#x3C;\n42\n</code></pre>\n<p>The log record for the request reads as follows:<br>\n<code>2019-01-04 ... FooService: Result: 42 CLIENT-ID=123, FOO=BAR</code></p>\n<p>We have therefore successfully added information to the context, which ended up both in the response headers and in the log message, together with the context from the callee.</p>\n<blockquote>\n<p>The entire project is on <a href=\"https://github.com/tkp1n/mdc-webflux\">github</a> for your reference.</p>\n</blockquote>","fields":{"slug":"/logging-with-context-in-spring-webflux/","prefix":"2018-01-05"},"frontmatter":{"title":"Logging with Context in Spring WebFlux (Part II)","author":"nicolas portmann","category":"Java","cover":{"childImageSharp":{"resize":{"src":"/static/2d14b869f8e9d805b771b83e8920c7ca/ada8c/markus-spiske-445253-unsplash.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/logging-with-context-in-spring-webflux/","prev":{"id":"49b07dc0-e0f7-56a6-bc81-4d2dfd27103e","fields":{"slug":"/passing-context-with-spring-webflux/","prefix":"2018-01-04","source":"posts"},"frontmatter":{"title":"Passing Context with Spring WebFlux (Part I)","category":"Java"}},"source":"posts"}}