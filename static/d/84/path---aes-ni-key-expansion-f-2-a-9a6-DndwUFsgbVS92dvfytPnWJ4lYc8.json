{"data":{"post":{"id":"fa081d40-450b-532d-8af3-d9ff152af2cb","html":"<blockquote>\n<p>This is the second post of a small series on AES-NI and .NET Core hardware intrinsics. Please have a look at the <a href=\"https://ndportmann.com/improving-dotnet-crypto-code/\">first post</a> and be patient for the next post, to which I’ll add the links once they are ready.</p>\n</blockquote>\n<p>We concluded the last post in this series with the realization, that the .NET frameworks AES implementation isn’t optimized for encrypting small payloads with quickly changing keys. Creating the <code class=\"language-text\">ICryptoTransform</code> for the ever-changing AES keys in the brute-force code we analyzed in the last post was responsible for about 60% of the total runtime of the “attack”.</p>\n<p>This post will, therefore, focus on how we can reduce this overhead by implementing only the absolute minimum required to work with a new AES key; the key expansion. The AES key expansion is required to expand the 128-, 192- or 256-bits of keying material to a key schedule of 10, 12 or 14 round keys (128-bits each). The exact nature of this process is described in detail in <a href=\"https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf\">NIST FIPS 197</a> which standardized AES in 2001. As this series is about .NET hardware intrinsics, we also refer to the <a href=\"https://www.intel.com/content/dam/doc/white-paper/advanced-encryption-standard-new-instructions-set-paper.pdf\">Intel white-paper</a> which introduced the use of Intel’s AES instructions in 2008.</p>\n<h2>History lesson (skip if you are not interested)</h2>\n<p>In 2008, most AES implementations were written entirely in software. There were some FPGAs and likely even ASICs for AES but not in consumer hardware. The software implementations were highly optimized but still relatively slow compared to applications based on current CPUs supporting AES-NI. The most common optimization trick was using lookup tables to avoid expensive calculations during encryption/decryption. This optimization technique, however, opened the door for an entire set of attacks against those AES implementations. As the lookup tables are typically big enough that they don’t fit into a single cache line, cache/timing side-channel attacks became possible. Other possible weaknesses of the software implementations included, of course, human error (speak: security bugs) which may have led to data-dependent timing or completely different attack vectors.</p>\n<p>Introducing AES-NI: It is very uncommon, that a piece of software/hardware increases both security and performance. AES-NI is one of those precious pieces of tech. With the tricky bits of AES implemented in hardware (the CPU) and exposed to application and library developers as hardware intrinsics, highly performant and secure AES implementations became a reality. Until recently, those intrinsics were mainly available to C/C++ developers, but with the introduction of hardware intrinsics in .NET Core 3.0 that all changed. The remainder of this blog series will focus on the journey of implementing AES in managed C# code using the AES-NI intrinsics provided in the current .NET Core preview.</p>\n<h2>AES key expansion</h2>\n<p>Back to the topic at hand. As indicated above, each AES key will be expanded to a 10, 12 or 14 round key schedule for encryption, and another equally sized key schedule for decryption (as AES-NI is based on the Equivalent Inverse Cipher approach described in <a href=\"https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf\">NIST FIPS 197</a>). This key schedule is typically calculated once and ahead of time. This ensures that the cost of the key expansion is amortized over its usage period. Implementations doing the key expansion on the fly are also possible but not profitable unless a minimal amount of blocks are encrypted with each key. To accommodate the key schedule we introduce a class per AES key size containing an array of 4 <code class=\"language-text\">int</code>s per round key required plus another 4 <code class=\"language-text\">int</code>s for the original key. The size of this array could be calculated as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>4</mn><mo>∗</mo><mo>(</mo><msub><mi>N</mi><mi>R</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">2 * 4 * (N_R + 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> (with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>N</mi><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">N_R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as the number of rounds). We can, however, save a few bytes by acknowledging, that the actual key (stored as <code class=\"language-text\">key[0]</code> in the schedule) is used by both the encryption and decryption algorithm. Furthermore, the last round key for the encryption is reused as the first round key while decrypting.</p>\n<p>This leaves us with the following formula to calculate the space required (in <code class=\"language-text\">int</code>s) for the key schedule: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>4</mn><mo>∗</mo><msub><mi>N</mi><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">2 * 4 * N_R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>\n<h2><code class=\"language-text\">class</code> vs. <code class=\"language-text\">readonly ref struct</code></h2>\n<p>One design decision was whether a <code class=\"language-text\">class</code> or a <code class=\"language-text\">readonly ref struct</code> would be the better home for the key schedule. The advantage of a <code class=\"language-text\">readonly ref struct</code> is the ability to wrap a <code class=\"language-text\">Span&lt;T&gt;</code> which would allow keeping the key schedule entirely on the stack (using <code class=\"language-text\">stackalloc</code>) and avoid heap allocations. There are however many downsides to <code class=\"language-text\">ref structs</code>:</p>\n<ul>\n<li>An instance of a key schedule represented as a class can be referred to by many threads.</li>\n<li>It is exponentially more convenient for consumers if they can keep a reference to the key (schedule) on the heap if it is used over a prolonged period of time.</li>\n<li>Inheritance and <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch#type-pattern\">type patterns</a> (<a href=\"https://github.com/tkp1n/AesNi/blob/ee982b8fd3a5a9cbfb40af7c30259e286f12e8bb/AesNi/Aes.cs#L67\">as used here</a>) are the idiomatic way to handle “same but different”-problems in C#. In fact, it even allows keeping the APIs clear of the actual types of keys and to transparently apply the correct AES variant (AES-128, AES-192 or AES-256) to a given problem based on the type of the provided key.</li>\n</ul>\n<p>With so many arguments in favor of classes, the decision is clear. We must, however, find a way to accommodate for the “brute-force attack” use case from the first post. The current design decision would require us to allocate a new instance of the AES-256 class (including a 2 * 4 * 14 <code class=\"language-text\">int</code> array) for every key we would like to try out. Unacceptable. As a work-around to my own design decision, I introduced the instance method <code class=\"language-text\">ReKey</code> which performs the key expansion for a new input key and stores it in the internal array of the key instance. A dirty trick (breaking the thread safety of the key instances) to improve the performance of the brute-force attack, which I will most likely reconsider in the future.</p>\n<h2>Implementation</h2>\n<p>The actual implementation of the key expansion revolves around the instruction <code class=\"language-text\">AESKEYGENASSIST</code> and is provided by <a href=\"https://www.intel.com/content/dam/doc/white-paper/advanced-encryption-standard-new-instructions-set-paper.pdf\">Intels white-paper</a> in figures 24, 25 and 26. It is important to note, that referenced figures of the white-paper only illustrate the key expansion for the encryption half of the key schedule. The decryption key schedule is calculated by applying the instruction <code class=\"language-text\">AESIMC</code> (IMC = InverseMixColumns) to the round keys <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1..</mn><msub><mi>N</mi><mi>R</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1..N_R-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> of the encryption key schedule.</p>\n<p>Porting the C code provided by Intel to C# is relatively straight forward, but still rather cumbersome. It could be described as the following “algorithm”:</p>\n<ul>\n<li>Treat all <code class=\"language-text\">__m128i</code> variables as <code class=\"language-text\">Vector128&lt;?&gt;</code> (use common sense to determine <code class=\"language-text\">?</code> in a way that minimizes the need for step 3 below)</li>\n<li>\n<p>For each intrinsic in the C code do:</p>\n<ul>\n<li>Copy the name of the intrinsic and search for it in the coreclr repository</li>\n<li>Find the equivalent name of the C# intrinsic and use it in your C# code</li>\n<li>If required, use the <code class=\"language-text\">AsXYZ()</code> extension methods on the <code class=\"language-text\">Vector128&lt;?&gt;</code> class to make the type system happy</li>\n</ul>\n</li>\n</ul>\n<p>Egor Bogatov is currently busy automating this exact process <a href=\"https://twitter.com/EgorBo/status/1106006223390953473\">https://twitter.com/EgorBo/status/1106006223390953473</a></p>\n<h2>Usage</h2>\n<p>The entire source is available on my GitHub as <a href=\"https://github.com/tkp1n/AesNi\">AesNi</a>. The following snippet showcases the usage of the key expansion as well as the reusability of the <code class=\"language-text\">key</code> instance using the <code class=\"language-text\">ReKey</code> method.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">var</span> keyBytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">32</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// fill with actual key</span>\n<span class=\"token keyword\">var</span> key <span class=\"token operator\">=</span> AesKey<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span>keyBytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// creates reusable instance of Aes256Key</span>\n\n<span class=\"token comment\">// use initial key schedule</span>\nAes<span class=\"token punctuation\">.</span><span class=\"token function\">Decrypt</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">,</span> iv<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> CipherMode<span class=\"token punctuation\">.</span>CBC<span class=\"token punctuation\">,</span> PaddingMode<span class=\"token punctuation\">.</span>None<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nkeyBytes <span class=\"token operator\">=</span> <span class=\"token comment\">// generate some other key</span>\nkey<span class=\"token punctuation\">.</span><span class=\"token function\">ReKey</span><span class=\"token punctuation\">(</span>keyBytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// performs inplace key expansion</span>\n\n<span class=\"token comment\">// use new key schedule</span>\nAes<span class=\"token punctuation\">.</span><span class=\"token function\">Decrypt</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">,</span> iv<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> CipherMode<span class=\"token punctuation\">.</span>CBC<span class=\"token punctuation\">,</span> PaddingMode<span class=\"token punctuation\">.</span>None<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Performance results</h2>\n<p>As mentioned above, the code using the .NET frameworks AES implementation spends </p>","fields":{"slug":"/aes-ni-key-expansion/","prefix":"2019-03-15"},"frontmatter":{"title":"AES-NI (.NET) - Key Expansion","author":"nicolas portmann","category":"crypto","cover":{"childImageSharp":{"resize":{"src":"/static/e2a96419a303d41b6619a1895f4ff96b/ada8c/sebastian-davenport-handley-746868-unsplash.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/aes-ni-key-expansion/","prev":{"id":"7064e1f5-662f-5a68-8320-062108eb9a46","fields":{"slug":"/improving-dotnet-crypto-code/","prefix":"2019-03-13","source":"posts"},"frontmatter":{"title":"Improving the performance of .NET crypto code","category":"crypto"}},"source":"posts"}}