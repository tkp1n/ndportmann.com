{"data":{"post":{"id":"911d88cb-03a5-5942-8e79-a477a2e3df91","html":"<blockquote>\n<p>This is the third and last post of a small series on AES-NI and .NET Core hardware intrinsics. Please also have a look at the <a href=\"https://ndportmann.com/improving-dotnet-crypto-code/\">first post</a> and the <a href=\"https://ndportmann.com/aes-ni-key-expansion/\">second post</a>.</p>\n</blockquote>\n<h2>The challenge</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">We have a message for you.\nIt’s 3ncryp73d and we want you to crack it.\nThe decrypted message will contain further instructions.\n\nKnowns:\n- The algorithm is AES (Rijndael)\n- Blocksize: 128\n- Keysize: 256\n- You only need to find the first 6 bytes of the key, the rest are 0’s, so:\n    [?,?,?,?,?,?,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n- All bytes in the key has an integer value between 0 and 16.\n- The initialization vector is (base64 encoded): &quot;DkBbcmQo1QH+ed1wTyBynA==&quot;\n- The text is just plain ASCII english\n\nThe encrypted text (base64 encoded):\n\nyptyoDdVBdQtGhgoePppYHnWyugGmy0j81sf3zBeUXEO/LYRw+2XmVa0/v6YiSy9Kj8gMn/gNu2I7dPmfgSEHPUDJpNpiOWmmW1/jw/Pt29Are5tumWmnfkazcAb23xe7B4ruPZVxUEhfn/IrZPNZdr4cQNrHNgEv2ts8gVFuOBU+p792UPy8/mEIhW5ECppxGIb7Yrpg4w7IYNeFtX5d9W4W1t2e+6PcdcjkBK4a8y1cjEtuQ07RpPChOvLcSzlB/Bg7UKntzorRsn+y/d72qD2QxRzcXgbynCNalF7zaT6pEnwKB4i05fTQw6nB7SU1w2/EvCGlfiyR2Ia08mA0GikqegYA6xG/EAGs3ZJ0aQUGt0YZz0P7uBsQKdmCg7jzzEMHyGZDNGTj0F2dOFHLSOTT2/GGSht8eD/Ae7u/xnJj0bGgAKMtNttGFlNyvKpt2vDDT3Orfk6Jk/rD4CIz6O/Tnt0NkJLucHtIyvBYGtQR4+mhbfUELkczeDSxTXGDLaiU3de6tPaa0/vjzizoUbNFdfkIly/HWINdHoO83E=\n\n\nTrustpilot Development Team\nBiting the red pill</code></pre></div>\n<blockquote>\n<p>Trustpilot: <a href=\"http://followthewhiterabbit.trustpilot.com/challenge2.html\">http://followthewhiterabbit.trustpilot.com/challenge2.html</a></p>\n</blockquote>\n<h2>77.332 s - A solid baseline</h2>\n<p>In the <a href=\"https://ndportmann.com/improving-dotnet-crypto-code/\">first post</a> of this series we analized a straight forward implementation of an AES brute-force attack on a known ciphertext. The task at hand basically requires us to decrypt a given ciphertext with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><msup><mn>6</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">16^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span> different keys which should yield a human-readable plaintext in roughly <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mn>1</mn><msup><mn>6</mn><mn>6</mn></msup></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">16^6 \\over 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.36292em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01792em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\"><span class=\"mord mtight\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913142857142857em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> operations. To determine whether the plaintext produced by the burte-force attack is acutally human-readable, we search for the string “trust” which we expect to be part of the plaintext. </p>\n<p>If all you care about is solving the challenge quoted above, <a href=\"https://github.com/ronnieholm/Playground/blob/012c19b8b6035704e522b4d9a875164ae6f54ac6/TrustpilotAesChallenge/CSharp/Program.cs\">this</a> may be the source you come up with and there is nothing wrong with that. You may however be slightly offended when you realize, that the execution time of the reference C# snippet is over an order of magnitued </p>\n<h2>10.263 s - Best bang for the buck</h2>\n<h2>2.063 s - Flexing the intrinics muscles</h2>\n<h2>387 ms - Now we’re just showing off</h2>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th align=\"right\">Workstation</th>\n<th align=\"right\">MacBook</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FwOriginal</td>\n<td align=\"right\">77.332 s</td>\n<td align=\"right\">129.432 s</td>\n</tr>\n<tr>\n<td>FwOptimized</td>\n<td align=\"right\">10.263 s</td>\n<td align=\"right\">14.820 s</td>\n</tr>\n<tr>\n<td>AesNiOriginal</td>\n<td align=\"right\">2.063 s</td>\n<td align=\"right\">2.716 s</td>\n</tr>\n<tr>\n<td>AesNiParallel</td>\n<td align=\"right\">0.387 s</td>\n<td align=\"right\">1.593 s</td>\n</tr>\n</tbody>\n</table>","fields":{"slug":"/aes-ni-outperforming-c-and-openssl/","prefix":"2019-04-08"},"frontmatter":{"title":"AES-NI (.NET) - Outperforming C and OpenSSL","author":"nicolas portmann","category":"crypto","cover":{"childImageSharp":{"resize":{"src":"/static/e70a122a99dd64bc3ae5efde5615e421/ada8c/marc-olivier-jodoin-291607-unsplash.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/aes-ni-outperforming-c-and-openssl/","prev":{"id":"cfd40d17-fb8b-57a9-be7b-400d19e3209c","fields":{"slug":"/aes-ni-key-expansion/","prefix":"2019-03-18","source":"posts"},"frontmatter":{"title":"AES-NI (.NET) - Key Expansion","category":"crypto"}},"source":"posts"}}