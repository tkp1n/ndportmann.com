{"data":{"post":{"id":"49b07dc0-e0f7-56a6-bc81-4d2dfd27103e","html":"<p>With traditional Jakarta EE (Java EE) or Spring projects, we utilize <a href=\"https://logback.qos.ch/manual/mdc.html\">MDCs (Mapped Diagnostic Context)</a> - a feature from SLF4J - to enrich logs with contextual data. Such contextual data might include but is not limited to the following:</p>\n<ul>\n<li>Request ID,</li>\n<li>DNS name of the hardware involved in processing the request,</li>\n<li>The ID of the client initiating the request</li>\n</ul>\n<p>In a microservices environment, this information is then typically passed to all services involved in handling a specific client request. Although <a href=\"https://tools.ietf.org/html/rfc6648\">deprecated</a> we examine, how to best pass context information between services as HTTP non-standard <code>X-</code> headers. We also investigate in the second part of this post, how to use constructs such as MDCs in a reactive environment, where <code>ThreadLocal</code>s cannot be used to store context. </p>\n<p>The solution to the latter is a variation of <a href=\"https://simonbasle.github.io/2018/02/contextual-logging-with-reactor-context-and-mdc/\">this excellent idea by Simon Basle</a>. I suggest you skim over it before reading the second part, a link to which you can find at the very bottom of this page.</p>\n<h2>Handling headers with WebFilters</h2>\n<p><code>WebFilter</code>s function much like their <a href=\"https://www.oracle.com/technetwork/java/filters-137243.html\">servelt counterparts</a>, but using Spring and Reactor specific APIs. </p>\n<p>To start, we start we create a Spring <code>@Component</code> implementing the <code>WebFilter</code> interface. In this component, we register two methods, one for copying the MDCs passed as request headers to the context, a second one to copy the context to the response. Context, in this case, refers to a <a href=\"https://projectreactor.io/docs/core/release/reference/#context\">well documented</a> concept to handle orthogonal concerns with Reactor (one of the building blocks of Spring WebFulx). </p>\n<pre><code class=\"language-java\">@Component\npublic class MdcHeaderFilter implements WebFilter {\n    @Override\n    @NonNull\n    public Mono&#x3C;Void> filter(\n        @NonNull ServerWebExchange ex, \n        @NonNull WebFilterChain chain) {\n        ex.getResponse().beforeCommit(\n            () -> addContextToHttpResponseHeaders(ex.getResponse())\n        );\n\n        return chain.filter(ex)\n                .subscriberContext(\n                    ctx -> addRequestHeadersToContext(ex.getRequest(), ctx)\n                );\n    }\n}\n</code></pre>\n<p>Although it might not look like it, <code>addRequestHeaderstToContext</code> gets invoked first (in fact before any <code>@Controller</code>s) and <code>addContextToHttpResponseHeaders</code> is called after the request has been processed by the respective controller. There is one caveat, we should address right away to avoid unpleasant surprises in the future. The <code>beforeCommit</code> callback gets executed only if the request handlers leave no exception uncaught. As context in logs is especially important, if something goes wrong, we shall make sure, that no exception goes uncaught (I had to learn this the hard way...). There are many solutions to solve this; we'll go with a <code>@ControllerAdvice</code> capable of improvement for now:</p>\n<pre><code class=\"language-java\">@ControllerAdvice\npublic class WebExceptionHandler {\n    @ExceptionHandler\n    @ResponseBody\n    public Mono&#x3C;ResponseEntity&#x3C;String>> gottaCatchEmAll(\n        Exception e, \n        ServerWebExchange ex) {\n\n        return Mono.just(\n            ResponseEntity\n                .status(status)\n                .body(e.getMessage())\n        );\n    }\n}\n</code></pre>\n<p>With that out of the way, we take a look at the two callbacks from the <code>WebFilter</code>. <code>addRequestHeaderstToContext</code> inspects all headers of every request passed through it and extracts all headers starting with <code>X-MDC-</code> and populates a Map with them. Before returning, the Map is added to the context passed as a parameter to the method. A mutable map is now stored within the otherwise immutable <code>Context</code>, allowing us to quite easily add additional context information in the handlers as we shall see soon. </p>\n<pre><code class=\"language-java\">private static final String MDC_HEADER_PREFIX = \"X-MDC-\";\nprivate static final String CONTEXT_MAP = \"context-map\";\n\nprivate Context addRequestHeadersToContext(\n        final ServerHttpRequest request,\n        final Context context) {\n\n    final Map&#x3C;String, String> contextMap = request\n            .getHeaders().toSingleValueMap().entrySet()\n            .stream()\n            .filter(x -> x.getKey().startsWith(MDC_HEADER_PREFIX))\n            .collect(\n                    toMap(v -> v.getKey().substring(MDC_HEADER_PREFIX.length()),\n                            Map.Entry::getValue\n                    )\n            );\n\n    return context.put(CONTEXT_MAP, contextMap);\n}\n</code></pre>\n<p>The purpose of <code>addContextToHttpResponseHeaders</code> is the exact opposite. It prefixes all entries in the context map with <code>X-MDC-</code> and adds them to the response headers.</p>\n<pre><code class=\"language-java\">private Mono&#x3C;Void> addContextToHttpResponseHeaders(\n        final ServerHttpResponse res) {\n\n    return Mono.subscriberContext().doOnNext(ctx -> {\n        if (!ctx.hasKey(CONTEXT_MAP)) return;\n\n        final HttpHeaders headers = res.getHeaders();\n        ctx.&#x3C;Map&#x3C;String, String>>get(CONTEXT_MAP).forEach(\n                (key, value) -> headers.add(MDC_HEADER_PREFIX + key, value)\n        );\n    }).then();\n}\n</code></pre>\n<blockquote>\n<p>An aside: In Spring 5.0.4 this was not working as expected which motivated me to open my first <a href=\"https://jira.spring.io/browse/SPR-16597\">issue</a> with Spring. Luckily it was quickly addressed and fixed in Spring 5.0.5.</p>\n</blockquote>\n<h2>Summary</h2>\n<p>With a simple demo controller, we shall now verify whether our filter works as expected. </p>\n<pre><code class=\"language-java\">@RestController\npublic class DemoController {\n    private static final Collector&#x3C;CharSequence, ?, String> COLLECTOR\n            = Collectors.joining(\",\" + System.lineSeparator(), \"[\", \"]\");\n\n    private static Mono&#x3C;String> apply(String prefix) {\n        return Mono.subscriberContext()\n                .map(x -> x.&#x3C;Map&#x3C;String, String>>get(CONTEXT_MAP))\n                .map(x -> prefix + x.entrySet().stream()\n                        .map(kv -> kv.getKey() + \": \" + kv.getValue())\n                        .collect(COLLECTOR));\n    }\n\n    @GetMapping(\"/demo\")\n    public Mono&#x3C;String> demo() {\n        return Mono.just(\"The context contains: \" + System.lineSeparator())\n                .flatMap(DemoController::apply);\n    }\n}\n</code></pre>\n<p>Above REST controller responds to requests to <code>/demo</code> with the content of the current context. Let's see, how it works out.</p>\n<pre><code class=\"language-bash\">$ curl -v -H \"X-MDC-FOO: BAR\" localhost:8080/demo\n> GET /demo HTTP/1.1\n> Host: localhost:8080\n> User-Agent: curl/7.58.0\n> Accept: */*\n> X-MDC-FOO: BAR\n>\n&#x3C; HTTP/1.1 200 OK\n&#x3C; Content-Type: text/plain;charset=UTF-8\n&#x3C; Content-Length: 34\n&#x3C; X-MDC-FOO: BAR\n&#x3C;\nThe context contains:\n[FOO: BAR]\n</code></pre>\n<p>You might have noticed, that the context is returned as response headers. Very well and just as expected. In part two, we investigate how we can add more information to the context, and leverage it in the application logs.</p>\n<blockquote>\n<p>The entire project (including part two) is on <a href=\"https://github.com/tkp1n/mdc-webflux\">github</a> for your reference.</p>\n</blockquote>","fields":{"slug":"/passing-context-with-spring-webflux/","prefix":"2018-01-04"},"frontmatter":{"title":"Passing Context with Spring WebFlux (Part I)","author":"nicolas portmann","category":"Java","cover":{"childImageSharp":{"resize":{"src":"/static/bff675e664834c0b5731c75046b1d565/ada8c/rawpixel-678089-unsplash.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/passing-context-with-spring-webflux/","prev":{"id":"9bdda9dc-2b9c-5305-b081-d89e82cdfd5c","fields":{"slug":"/system-threading-channels/","prefix":"2018-01-03","source":"posts"},"frontmatter":{"title":"Exploring System.Threading.Channels","category":"dotnet"}},"next":{"id":"4f7efefe-ed6d-5787-bc07-289eb60587cf","fields":{"slug":"/logging-with-context-in-spring-webflux/","prefix":"2018-01-05","source":"posts"},"frontmatter":{"title":"Logging with Context in Spring WebFlux (Part II)","category":"Java"}},"source":"posts"}}