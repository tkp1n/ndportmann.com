{"data":{"post":{"id":"dd08c0c2-d919-5738-b2bf-40847cdf937e","html":"<p>Prior to the introduction of <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#ref-locals-and-returns\">ref returns and ref locals in C# 7.0</a> and the following improvements such as <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-2#conditional-ref-expressions\">conditional ref expressions in C# 7.2</a> and <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-3#ref-local-variables-may-be-reassigned\">ref reassignments in C# 7.3</a> there was no way to perform pointer arithmetics in C# without going <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/index\">unsafe</a>. This post explores <code class=\"language-text\">System.Runtime.CompilerServices.Unsafe</code> a class capable of replacing both the <code class=\"language-text\">unsafe</code> and the <code class=\"language-text\">fixed</code> keywords from you codebase. Be aware however, that doing so will not increase the readability of you code base, if anything the opposite is the case. But it could very well make it faster.</p>\n<p>The <code class=\"language-text\">fixed</code> keyword in C# pins an object in memory. This prohibits the GC from moving, while you operate on the object using a pointer. This implies additional bookkeeping for the GC, which should generally be avoided if possible (see “Rule 22: Avoid pinning” in <a href=\"https://prodotnetmemory.com/\">Pro .NET Memory Management by Konrad Kokosa</a>). In addition using the <code class=\"language-text\">fixed</code> keyword may prevent inlining of the method using it (see <a href=\"https://twitter.com/buybackoff/status/882256068855910400\">this tweet by Victor Baybekov</a> including the PRs in the comments).</p>\n<h2>Obtaining a reference</h2>\n<p>Before we can perform any kind of pointer arithmetic we need to obtain a reference to an object, or an array more specifically. There are multiple ways to do so:</p>\n<p>The simplest way the can be achieved with the language features provided by C# 7.0 and above. </p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">ref</span> <span class=\"token keyword\">byte</span> ptr <span class=\"token operator\">=</span> <span class=\"token keyword\">ref</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\">Span<span class=\"token operator\">&lt;</span><span class=\"token keyword\">byte</span><span class=\"token operator\">></span> span <span class=\"token operator\">=</span> <span class=\"token keyword\">stackalloc</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">ref</span> <span class=\"token keyword\">byte</span> ptr <span class=\"token operator\">=</span> <span class=\"token keyword\">ref</span> MemoryMarshal<span class=\"token punctuation\">.</span><span class=\"token function\">GetReference</span><span class=\"token punctuation\">(</span>span<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"></code></pre></div>","fields":{"slug":"/system-runtime-compilerservices-unsafe/","prefix":"2019-01-26"},"frontmatter":{"title":"Exploring System.Runtime.CompilerServices.Unsafe","author":"nicolas portmann","category":"dotnet","cover":{"childImageSharp":{"resize":{"src":"/static/b864d7fab0550d70b724023a694ddd52/ada8c/joey-banks-380271-unsplash.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/system-runtime-compilerservices-unsafe/","prev":{"id":"2b47e67e-5cd4-5c7f-9ae9-4d42a24ae77f","fields":{"slug":"/logging-with-context-in-spring-webflux/","prefix":"2019-01-05","source":"posts"},"frontmatter":{"title":"Logging with Context in Spring WebFlux (Part II)","category":"java"}},"source":"posts"}}