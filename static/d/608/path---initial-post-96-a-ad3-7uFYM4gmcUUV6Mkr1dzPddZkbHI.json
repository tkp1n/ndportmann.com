{"data":{"post":{"id":"75d36946-bf5a-52de-88ce-2cc84022ae33","html":"<p>The <code class=\"language-text\">System.Threading.Channels</code> namespace provides data structures (stores) for pub/sub scenarios. It enables you to decouple one-to-many publishers from one-to-many subscribers just as its equally named counterpart from <a href=\"https://tour.golang.org/concurrency/2\">go</a>.</p>\n<blockquote>\n<p>At first glance, this might look similar to the functionality provided by <code class=\"language-text\">System.Threading.Task.Dataflow</code> (especially by <code class=\"language-text\">BufferBlock&lt;T&gt;</code>).\n<code class=\"language-text\">Channels</code>, however, are a more low-level primitive upon which libraries such as <code class=\"language-text\">Dataflow</code> can be built.\nIf the library was in development today, it would most certainly be based on <code class=\"language-text\">Channels</code>.</p>\n</blockquote>\n<h2>Bound vs. Unbound Channels</h2>\n<p>Channels are created using the static factory methods of the Channel class.\nThe type parameter <code class=\"language-text\">T</code> is used to identify the type of object that can be passed from a publisher to a subscriber via the created channel.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Channel<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token generic-method\"><span class=\"token function\">CreateBounded</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Channel<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token generic-method\"><span class=\"token function\">CreateBounded</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BoundedChannelOptions</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Channel<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token generic-method\"><span class=\"token function\">CreateUnbounded</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Channel<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token generic-method\"><span class=\"token function\">CreateUnbounded</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UnboundedChannelOptions</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>Using <code class=\"language-text\">CreateUnbounded</code> will create a channel that can accept an infinite amount of messages - given an endless amount of memory of course. The unbounded channel variant is more performant than its bounded counterpart in almost every benchmark (see below). This win in performance comes at the cost of potentially running out of memory. If you can externally guarantee, that the channel will never contain more then a certain amount of pending objects, using an unbounded channel is profitable. Otherwise, it is more secure to rely on bounded channels.</p>\n<p>Bounded channles operate in one of four full modes, which can be set via the options parameter to the <code class=\"language-text\">CreateBounded</code> factory mehtod.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\">Channel<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">CreateBounded</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BoundedChannelOptions</span><span class=\"token punctuation\">(</span>capacity<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    FullMode <span class=\"token operator\">=</span> BoundedChannelFullMode<span class=\"token punctuation\">.</span>Wait\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The four supported full modes are:</p>\n<ul>\n<li><code class=\"language-text\">Wait</code> - Wait for space to be available in order to complete the write operation.</li>\n<li><code class=\"language-text\">DropNewest</code> - Remove and ignore the newest item in the channel in order to make room for the item being written.</li>\n<li><code class=\"language-text\">DropOldest</code> - Remove and ignore the oldest item in the channel in order to make room for the item being written.</li>\n<li><code class=\"language-text\">DropWrite</code> - Drop the item being written.</li>\n</ul>\n<p>Be aware that the most convenient option <code class=\"language-text\">Wait</code> might also cause memory issues, as each asynchronously ‘waiting’ producer requires memory.</p>\n<h2>Publisher / Subscriber cardinality</h2>\n<p>Channels are assumingly used to coordinate one publisher with the computing power of multiple subscribers, or to fit the work of multiple producers through the bottleneck of a single consumer. It is however also possible to model multi-publisher / multi-subscriber or single-publisher / single-subscriber scenarios using channels.\nBoth options</p>\n<p>To notify of the factory methods of the specific scenario at hand, two properties on both the <code class=\"language-text\">Unbounded</code>- and the <code class=\"language-text\">BoundedChannelOptions</code>can be set accordingly.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\">Channel<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">CreateUnbounded</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">UnboundedChannelOptions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    SingleWriter <span class=\"token operator\">=</span> <span class=\"token keyword\">false</span><span class=\"token punctuation\">,</span>\n    SingleReader <span class=\"token operator\">=</span> <span class=\"token keyword\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The CoreFX repository contains three implementations of the abstract <code class=\"language-text\">Channel&lt;T&gt;</code> class; one bounded Channel, one single-consumer and one multi-consumer unbounded channel. Unless specifying a single-consumer scenario to the unbounded channel factory, there is currently no effect in setting those properties. It is however still considered best-practice, as more implementations might be added in the future.</p>\n<table>\n<thead>\n<tr>\n<th>SyncCont.</th>\n<th>Pub/Sub</th>\n<th>Speed</th>\n<th>Type</th>\n<th align=\"right\">Mean</th>\n<th align=\"right\">Median</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>10/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>778.8 ms</strong></td>\n<td align=\"right\"><strong>762.7 ms</strong></td>\n</tr>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>10/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>387.0 ms</strong></td>\n<td align=\"right\"><strong>378.7 ms</strong></td>\n</tr>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>10/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>524.7 ms</strong></td>\n<td align=\"right\"><strong>488.7 ms</strong></td>\n</tr>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>10/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>372.0 ms</strong></td>\n<td align=\"right\"><strong>354.6 ms</strong></td>\n</tr>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>1/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>2,254.3 ms</strong></td>\n<td align=\"right\"><strong>2,287.6 ms</strong></td>\n</tr>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>1/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>179.9 ms</strong></td>\n<td align=\"right\"><strong>177.4 ms</strong></td>\n</tr>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>1/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>492.7 ms</strong></td>\n<td align=\"right\"><strong>503.1 ms</strong></td>\n</tr>\n<tr>\n<td><strong>False</strong></td>\n<td><strong>1/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>289.3 ms</strong></td>\n<td align=\"right\"><strong>291.1 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>10/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>745.1 ms</strong></td>\n<td align=\"right\"><strong>749.9 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>10/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>508.6 ms</strong></td>\n<td align=\"right\"><strong>524.4 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>10/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>625.8 ms</strong></td>\n<td align=\"right\"><strong>594.7 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>10/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>381.4 ms</strong></td>\n<td align=\"right\"><strong>369.7 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>1/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>845.4 ms</strong></td>\n<td align=\"right\"><strong>836.8 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>1/10</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>846.8 ms</strong></td>\n<td align=\"right\"><strong>856.9 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>1/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Bounded</strong></td>\n<td align=\"right\"><strong>351.5 ms</strong></td>\n<td align=\"right\"><strong>352.8 ms</strong></td>\n</tr>\n<tr>\n<td><strong>True</strong></td>\n<td><strong>1/1</strong></td>\n<td><strong>Balanced</strong></td>\n<td><strong>Unbounded</strong></td>\n<td align=\"right\"><strong>319.7 ms</strong></td>\n<td align=\"right\"><strong>319.8 ms</strong></td>\n</tr>\n</tbody>\n</table>","fields":{"slug":"/initial-post/","prefix":"2017-10-21"},"frontmatter":{"title":"Exploring System.Threading.Channels","author":"nicolas portmann","category":"none","cover":{"childImageSharp":{"resize":{"src":"/static/c05f925825606e19a957283ac76dc0db/ada8c/photo-1465070845512-2b2dbdc6df66.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> About me…</p>"}},"pageContext":{"slug":"/initial-post/","source":"posts"}}