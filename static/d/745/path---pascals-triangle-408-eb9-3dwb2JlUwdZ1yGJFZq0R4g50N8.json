{"data":{"post":{"id":"02a0c736-732d-5ec7-802c-c7b40700924f","html":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1</code></pre></div>\n<p>As part of a recent job interview process, I was asked to submit an implementation of Pascal’s triangle in Scala. Pascal’s triangle is an excellent programming assignment as there is an almost endless amount of possible solutions. It is not particularly hard to solve, but how you solve it tells much about you as a software engineer.</p>\n<p>Pascal’s triangle is a pyramid best explained by the following quote. Refer to above illustration as an example of the first 5 rows of Pascal’s triangle.</p>\n<blockquote>\n<p>Each entry of each subsequent row is constructed by adding the number above and to the left with the number above and to the right, treating blank entries as 0. - <a href=\"https://en.wikipedia.org/wiki/Pascal%27s_triangle\">Wikipedia</a></p>\n</blockquote>\n<p>I decided to set the following focus in my implementation:</p>\n<ul>\n<li>Concieness</li>\n<li>Simplicity</li>\n<li>Turning edge cases into normal cases</li>\n<li>Core logic as a one-liner</li>\n</ul>\n<p>To achieve the above I accepted to neglect the following aspects:</p>\n<ul>\n<li>input validation</li>\n<li>performance</li>\n<li>pretty printing</li>\n</ul>\n<p>But talk is cheap, so without furhter ado, my solution:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> Pascal <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> rows <span class=\"token operator\">=</span> args<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>toInt\n\n    <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> until rows<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>scanLeft<span class=\"token punctuation\">(</span>Seq<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> calculateRow<span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>x <span class=\"token keyword\">=></span> x<span class=\"token punctuation\">.</span>mkString<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>foreach<span class=\"token punctuation\">(</span>println<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> calculateRow<span class=\"token punctuation\">(</span>previous<span class=\"token operator\">:</span> Seq<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Seq<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> <span class=\"token operator\">+</span><span class=\"token operator\">:</span> previous <span class=\"token operator\">:</span><span class=\"token operator\">+</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sliding<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>l <span class=\"token keyword\">=></span> l<span class=\"token punctuation\">.</span>head <span class=\"token operator\">+</span> l<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>toSeq\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>The good</h2>\n<p>I managed to get the core logic (transforming a given row into the next one) into one line: <code class=\"language-text\">claculateRow</code>.\nCentral to the approach is Scalas <code class=\"language-text\">sliding</code> function, which allows me to process the previous row using a sliding window of N (N=2 in this case) elements. As per above definition (from Wikipedia), all that is necessary is to add the two elements presented by the sliding window to calulate the next row which is exactly what is done by <code class=\"language-text\">map(l =&gt; l.head + l(1))</code>.\nThere is a caveat however. Above defintion implies a <code class=\"language-text\">0</code> to be added to the first and the last element of the previous row to calculate the first and last element of the current row. Implementing this implicit facet of the definition as <code class=\"language-text\">(0 +: previous :+ 0)</code> turns the literal edge cases into the normal case presented by all the elements between the first and the last ones.</p>\n<h2>The bad</h2>\n<p>Prefixing and suffixing the previous row with a <code class=\"language-text\">0</code> creates intermediate arrays (<code class=\"language-text\">Seq</code>s) which whilst helping simplicity surely hurts performance.\nDirectly parsing the argument to the <code class=\"language-text\">main</code> function <code class=\"language-text\">toInt</code> is of course not recommended for serious applications.</p>\n<h2>The ugly</h2>\n<p>Joining the rows using <code class=\"language-text\">mkString(&quot; &quot;)</code> is missing the neccessary pre- and suffixes to acutally print a triangle.\nThe output is therefore not pretty, but nevertheless correct.</p>","fields":{"slug":"/pascals-triangle/","prefix":"2019-02-15"},"frontmatter":{"title":"Pascal's triangle","author":"nicolas portmann","category":"scala","cover":{"childImageSharp":{"resize":{"src":"/static/45a8e06db2a0784be22b65ed39c2176b/ada8c/anton-kraev-1165305-unsplash.jpg"}}}}},"authornote":{"id":"37e21f59-b45d-5bbb-87bd-acb76a2de5c3","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/pascals-triangle/","prev":{"id":"7689cce5-e086-5fe2-a5f6-0c93165d7463","fields":{"slug":"/system-runtime-compilerservices-unsafe/","prefix":"2019-01-27","source":"posts"},"frontmatter":{"title":"Unsafe array access and pointer arithmetics in C#","category":"dotnet"}},"source":"posts"}}