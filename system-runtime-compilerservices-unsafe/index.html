<!DOCTYPE html><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Unsafe array access and pointer arithmetics in C#</title>
        <meta name="description" content="A Software Engineering Blog">
        <meta property="og:url" content="https://ndportmann.com/system-runtime-compilerservices-unsafe/">
        <meta property="og:title" content="Unsafe array access and pointer arithmetics in C#">
        <meta property="og:description" content="A blog about software engineering and applied cryptography.">
        <meta property="og:type" content="article">
        <meta name="twitter:site" content="@tkp1n">
        <meta name="twitter:creator" content="@tkp1n">
        <meta name="twitter:card" content="summary">
        <style>
            
            /*! tailwindcss v2.1.1 | MIT License | https://tailwindcss.com *//*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */*,::after,::before{box-sizing:border-box}:root{-moz-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Consolas,'Liberation Mono',Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}button{background-color:transparent;background-image:none}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}body{font-family:inherit;line-height:inherit}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}:root{--size-0_5:0.125rem;--size-1:0.250rem;--size-1_5:0.375rem;--size-2:0.5rem;--size-3:0.75rem;--size-3_5:0.875rem;--size-4:1rem;--size-4_5:1.125rem;--size-5:1.25rem;--size-6:1.5rem;--size-7:1.75rem;--size-7_5:1.875rem;--size-8:2rem;--size-9:2.25rem;--size-10:2.5rem;--size-xs:20rem;--size-md:28rem;--weight-extralight:200;--weight-light:300;--weight-bitbold:400;--weight-semibold:600;--blue-500:rgba(59, 130, 246, 1);--blue-600:rgba(37, 99, 235, 1);--blue-800:rgba(37, 99, 235, 1);--white:rgba(255, 255, 255, 1);--gray-200:rgba(229, 231, 235, 1);--gray-500:rgba(107, 114, 128, 1);--gray-800:rgba(31, 41, 55, 1);--black:rgba(0, 0, 0, 1)}*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.max-w-screen-lg{max-width:1024px}.max-w-screen-md{max-width:768px}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.mx-auto{margin-left:auto;margin-right:auto}.shadow{--tw-shadow:0 1px 3px 0 rgba(0, 0, 0, 0.1),0 1px 2px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.rounded{border-radius:.25rem}h2{font-size:var(--size-5);line-height:var(--size-7);margin-left:var(--size-4);margin-top:var(--size-6)}@media (min-width:1024px){h2{font-size:var(--size-6);line-height:var(--size-8)}}h3{font-size:var(--size-4_5);line-height:var(--size-7);margin-top:var(--size-6);color:var(--gray-800);font-weight:var(--weight-semibold);letter-spacing:-.025em}@media (min-width:1024px){h3{font-size:var(--size-5);line-height:var(--size-7)}}h4{margin-top:var(--size-5);font-weight:var(--weight-semibold)}.icon{width:var(--size-5);height:var(--size-5);margin-bottom:var(--size-1);display:inline}.tag{padding-right:var(--size-3);white-space:nowrap}pre{border-radius:var(--size-1)}ul{list-style:disc;padding-left:var(--size-4_5)}ol{list-style:decimal;padding-left:var(--size-4_5)}blockquote{margin-top:1rem;padding-left:1rem;border-left:4px solid #dadada}th{text-align:start;font-weight:var(--weight-bitbold)}code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:0 0;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#8292a2}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.header h1{margin-top:0;font-size:var(--size-4_5);line-height:var(--size-7)}@media(min-width:1024px){.header h1{font-size:var(--size-5)}}.sub{font-size:var(--size-4);line-height:var(--size-6);font-weight:var(--weight-extralight);height:var(--size-6)}.sub span{animation:fade 10s linear infinite 0s;opacity:0;overflow:hidden;position:absolute}.sub span:nth-child(2){animation-delay:2.5s}.sub span:nth-child(3){animation-delay:5s}.sub span:nth-child(4){animation-delay:7.5s}@media(min-width:1024px){.sub{font-size:var(--size-4_5);line-height:var(--size-7)}}@keyframes fade{0%{opacity:0}5%{opacity:0}10%{opacity:1}25%{opacity:1}30%{opacity:0}100%{opacity:0}}.outer{margin-top:var(--size-8);background-color:var(--blue-600);transform:skewY(6deg);width:66.666667%;max-width:var(--size-xs);min-width:-webkit-min-content;min-width:min-content}@media(min-width:1024px){.outer{max-width:var(--size-md)}}.inner{padding:var(--size-2);background-color:var(--white);transform:skewY(-6deg);width:80%}header>h1{font-size:var(--size-6);line-height:var(--size-8);margin-top:var(--size-7)}@media(min-width:1024px){header>h1{font-size:var(--size-7);line-height:var(--size-9)}}h1,h2,h3,h4,h5,h6{margin-left:0}.content{max-width:768px;margin-top:var(--size-6);padding-right:var(--size-5);padding-left:var(--size-5)}.text{margin-top:var(--size-2);font-size:var(--size-4)}.text p{padding-top:var(--size-4)}.text a{color:var(--blue-600)}.text a:hover{text-decoration:underline}.text pre{margin-top:var(--size-1);margin-bottom:var(--size-1)}.text table{table-layout:auto;width:100%;margin-top:var(--size-2);margin-bottom:var(--size-2)}.text tr{border-bottom-width:1px}.text td{padding:var(--size-1_5)}:not(a)>code{border-radius:var(--size-1);padding:var(--size-0_5);background-color:var(--gray-200)}.text blockquote>p{padding-top:0}footer{padding-top:var(--size-4);padding-bottom:var(--size-2);width:100%;text-align:center}
        </style>
        <link rel="stylesheet" href="../prism-okaidia.min.css">
        <link rel="stylesheet" href="../katex.min.css">
    </head>
    <body>
        <a href="/" class="header">
            <div class="outer shadow rounded mx-auto">
                <div class="inner shadow rounded mx-auto">
                    <header>
                        <h1>Nicolas Portmann</h1>
                        <div class="sub">
                            <span>Software Engineering</span>
                            <span>Security Engineering</span>
                            <span>Applied Cryptography</span>
                            <span>Performance Optimization</span>
                        </div>
                    </header>
                </div>
            </div>
        </a>
        <div class="content container mx-auto">
            <main>
                <header>
                    <h1>Unsafe array access and pointer arithmetics in C#</h1>
                    
                    
    <section>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            <span class="meta">2019/01/27</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
            </svg>
            <span class="meta">Nicolas Portmann</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0
                        014-4z"></path>
            </svg>
            <span class="meta">.NET</span>
        </span>
    </section>

                </header>
                <article class="text">
                    <p>Before the introduction of <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#ref-locals-and-returns" title="Ref locals and returns - What's new in C# 7.0 through C# 7.3">ref returns and ref locals in C# 7.0</a> and following improvements such as <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-2#conditional-ref-expressions" title="Conditional ref Expressions - C#">conditional ref expressions in C# 7.2</a> and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-3#ref-local-variables-may-be-reassigned" title="Ref reassignments - C#">ref reassignments in C# 7.3</a> there was no way to perform pointer arithmetics in C# without going <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/index" title="unsafe code pointers - C#">unsafe</a>. This post explores <code>System.Runtime.CompilerServices.Unsafe</code> a class capable of replacing both the <code>unsafe</code> and the <code>fixed</code> keywords from your codebase. Be aware, that doing so does not increase the readability of your codebase if anything the opposite is the case. However, it could very well make it faster.</p>
<p>The <code>fixed</code> keyword in C# pins an object in memory and allows you to obtain an unmanaged pointer to it. Pinning prohibits the GC from moving the object to another memory location (e.g., during compaction), while you operate on the pointer. This, in turn, implies additional bookkeeping for the GC, which should generally be avoided if possible (see &quot;Rule 22: Avoid pinning&quot; in the excellent <a href="https://prodotnetmemory.com/" title="Pro .NET Memory Management - Konrad Kokosa">Pro .NET Memory Management by Konrad Kokosa</a>). Using the <code>fixed</code> keyword may also prevent inlining of the method using it (see <a href="https://twitter.com/buybackoff/status/882256068855910400" title="Victor Baybekov - Twitter">this tweet by Victor Baybekov</a> including the PRs in the comments).</p>
<p><code>System.Runtime.CompilerServices.Unsafe</code> is part of the .NET Platform Extensions which are documented <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe?view=dotnet-plat-ext-2.2" title="Unsafe - .NET Documentation">here</a> and can be obtained via <a href="https://www.nuget.org/packages/System.Runtime.CompilerServices.Unsafe/" title="System.Runtime.CompilerServices.Unsafe - NuGet">NuGet</a>. This post does not cover the entire API surface of <code>Unsafe</code> but focuses on accessing arrays (preferably without bounds checks) and doing pointer arithmetics.</p>
<h2>Why going unsafe in the first place?</h2>
<p>C# and .NET is an excellent platform for getting work done. It focuses on developer productivity, safety and ease of use.  To make sure code written in C# / .NET does look not only pretty but also performs good, framework and library authors must focus on performance. And you should probably too, but make sure to concentrate your efforts on the 1-3% of your code base, that are actually worth optimizing (<em>resisting the urge to quote Knuth here</em>). <code>unsafe</code> code allows you to go beyond what is possible in &quot;normal&quot; C# (Trivia: S.R.CS.Unsafe is written in IL as the concepts introduced by it cannot be expressed in any .NET language.). Things you can only do in <code>unsafe</code> code or using the <code>Unsafe</code> class include but are not limited to:</p>
<ul>
<li>Random access to arrays without bounds checks</li>
<li>Read from / write to &quot;random&quot; memory locations</li>
<li>Compare references (instead of the values they refer to)</li>
<li>Reinterpret (cast) a reference as a reference to a different type</li>
<li>Cast without dynamic type checks.</li>
</ul>
<p>This post will focus on the first three topics of the above list.</p>
<h2>Obtaining a reference</h2>
<p>Before we can perform any <code>Unsafe</code>-magic we need to obtain a reference to an object (an array in this case). There are multiple ways to do so.</p>
<p>The simplest way this is achieved is with the language features provided by C# 7.0 and above. Below sample is 100% safe and will throw if the array is <code>null</code> or the specified element does not exist. This safety comes at a cost of course (see <code>cmp</code> and <code>jbe</code> in below JIT dump).</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">byte</span></span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">byte</span></span> ptr <span class="token operator">=</span> <span class="token keyword">ref</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<pre class="language-nasm"><code class="language-nasm"><span class="token comment">; ref byte ArrayAccess(byte[] array) </span><br><span class="token comment">;     => ref array[0];</span><br><span class="token label function">L0000:</span> cmp dword <span class="token operator">[</span><span class="token register variable">edx</span><span class="token operator">+</span><span class="token number">0x4</span><span class="token operator">]</span>, <span class="token number">0x0</span><br><span class="token label function">L0004:</span> jbe L000a<br><span class="token label function">L0006:</span> lea <span class="token register variable">eax</span>, <span class="token operator">[</span><span class="token register variable">edx</span><span class="token operator">+</span><span class="token number">0x8</span><span class="token operator">]</span><br><span class="token label function">L0009:</span> ret<br><span class="token label function">L000a:</span> call <span class="token number">0x74033430</span><br><span class="token label function">L000f:</span> int3</code></pre>
<p>This method could also be used to obtain a reference to an element in the array at a given offset simply by replacing the <code>0</code> in above snippet with the desired element index.</p>
<p>There is a riskier but faster way to get a reference to the 0th element of a given <code>Span&lt;T&gt;</code> however. Make sure you only use this, if you are certain the span is non-null and not empty. The <code>Span&lt;T&gt;</code> variant is branch-free.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name">Span<span class="token punctuation">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">></span></span> span <span class="token operator">=</span> <span class="token keyword">stackalloc</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">byte</span></span> ptr <span class="token operator">=</span> <span class="token keyword">ref</span> MemoryMarshal<span class="token punctuation">.</span><span class="token function">GetReference</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre class="language-nasm"><code class="language-nasm"><span class="token comment">; ref byte SpanAccess(Span&lt;byte> span) </span><br><span class="token comment">;     => ref MemoryMarshal.GetReference(span);</span><br><span class="token label function">L0000:</span> lea <span class="token register variable">eax</span>, <span class="token operator">[</span><span class="token register variable">esp</span><span class="token operator">+</span><span class="token number">0x4</span><span class="token operator">]</span><br><span class="token label function">L0004:</span> push dword <span class="token operator">[</span><span class="token register variable">eax</span><span class="token operator">+</span><span class="token number">0x8</span><span class="token operator">]</span><br><span class="token label function">L0007:</span> push dword <span class="token operator">[</span><span class="token register variable">eax</span><span class="token operator">+</span><span class="token number">0x4</span><span class="token operator">]</span><br><span class="token label function">L000a:</span> push dword <span class="token operator">[</span><span class="token register variable">eax</span><span class="token operator">]</span><br><span class="token label function">L000c:</span> call dword <span class="token operator">[</span><span class="token number">0x52652d8c</span><span class="token operator">]</span><br><span class="token label function">L0012:</span> ret <span class="token number">0xc</span></code></pre>
<p>Below a collection of snippets try to translate <code>unsafe</code> code to code using <code>Unsafe</code>.
To make searching easier:</p>
<ul>
<li>all references/pointers are named <code>ptr</code>,</li>
<li>when comparing multiple references/pointers, they are named <code>ptr1</code> and <code>ptr2</code>,</li>
<li>the referenced type is assumed to be <code>int</code> (unless specified otherwise)</li>
<li>all values written are 0x42,</li>
<li>all offsets are 12.</li>
</ul>
<p>This should enable you to quickly find the appropriate <code>Unsafe</code> pattern for your existing <code>unsafe</code> code. Each snippet of <code>unsafe</code> code is immediately followed by the equivalent code pattern using the <code>Unsafe</code> class.</p>
<h2>Accessing arrays without bounds checks</h2>
<p>Given a reference to an element in an array, other elements in the same array can easily be accessed using the <code>Unsafe.Add</code> and <code>Unsafe.Subtract</code> methods to calculate offsets relative to the existing reference. Both methods calculate the number of bytes the reference has to be moved based on the type of the reference passed as the first parameter. Internally the implementation of <code>Unsafe.Add</code> could look something like this:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token comment">// https://github.com/dotnet/coreclr/blob/d1c1cc91a85c510c7b10461acb35b8c545fe2b07/src/System.Private.CoreLib/shared/Internal/Runtime/CompilerServices/Unsafe.cs#L108</span><br><span class="token keyword">return</span> <span class="token keyword">ref</span> <span class="token function">AddByteOffset</span><span class="token punctuation">(</span><span class="token keyword">ref</span> source<span class="token punctuation">,</span> <span class="token punctuation">(</span>IntPtr<span class="token punctuation">)</span><span class="token punctuation">(</span>elementOffset <span class="token operator">*</span> <span class="token punctuation">(</span>nint<span class="token punctuation">)</span><span class="token generic-method"><span class="token function">SizeOf</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>As the in memory position of the <code>int</code> at array position 12 is <code>ptr + sizof(int) * 12</code> the reference is increased by <code>48</code> to point to the correct element. Meaning that there is a simpler way of accessing byte arrays; you could use <code>Unsafe.AddByteOffset</code> or <code>Unsafe.SubtractByteOffset</code> directly.</p>
<h3>Adding offsets to references</h3>
<pre class="language-c"><code class="language-c">ptr<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><br><span class="token keyword">int</span><span class="token operator">*</span> x <span class="token operator">=</span> ptr <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">;</span><br><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">Unsafe<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><br><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token class-name"><span class="token keyword">int</span></span> y <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3>Subtracting offsets from references</h3>
<pre class="language-c"><code class="language-c">ptr<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><br><span class="token keyword">int</span><span class="token operator">*</span> x <span class="token operator">=</span> ptr <span class="token operator">-</span> <span class="token number">12</span><span class="token punctuation">;</span><br><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr <span class="token operator">-</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">Unsafe<span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><br><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token class-name"><span class="token keyword">int</span></span> y <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3>Adding offsets in iterations</h3>
<pre class="language-c"><code class="language-c"><span class="token operator">*</span>ptr<span class="token operator">++</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><br><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>ptr<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">ptr <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span> ptr <span class="token operator">=</span> <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span></code></pre>
<h3>Subtracting offsets in iterations</h3>
<pre class="language-c"><code class="language-c"><span class="token operator">*</span>ptr<span class="token operator">--</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><br><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>ptr<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">ptr <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span> ptr <span class="token operator">=</span> <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">(</span>ptr <span class="token operator">=</span> <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token function">Subtract</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span></code></pre>
<h2>Comparing references</h2>
<p>Certain use cases may require you to compare two references. Not the value they refer to, but the actual address. To make this clear, the references <code>ptr1</code> and <code>ptr2</code> refer to a different element in the array <code>arr</code>, yet C# only allows to compare the values they refer to, which are equal.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> ptr1 <span class="token operator">=</span> <span class="token keyword">ref</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> ptr2 <span class="token operator">=</span> <span class="token keyword">ref</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>ptr1 <span class="token operator">==</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -> 1 == 1 -> true</span></code></pre>
<p>This is where <code>Unsafe.AreSame</code> comes into play. It allows you to compare the address of two pointers and would, of course, return <code>false</code> in the above situation. Along the same lines <code>Unsafe.IsAddressLessThan</code> and <code>Unsafe.IsAddressGreaterThan</code> allow you to compare the relative position of two pointers.</p>
<h3>Address equality</h3>
<pre class="language-csharp"><code class="language-csharp">Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>ptr1 <span class="token operator">==</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>Unsafe<span class="token punctuation">.</span><span class="token function">AreSame</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr1<span class="token punctuation">,</span> <span class="token keyword">ref</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3>Address greater than / less than</h3>
<pre class="language-csharp"><code class="language-csharp">Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>ptr1 <span class="token operator">&lt;</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>ptr1 <span class="token operator">></span> ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>Unsafe<span class="token punctuation">.</span><span class="token function">IsAddressLessThan</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr1<span class="token punctuation">,</span> <span class="token keyword">ref</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>Unsafe<span class="token punctuation">.</span><span class="token function">IsAddressGreaterThan</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr1<span class="token punctuation">,</span> <span class="token keyword">ref</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3>Calculate address differences</h3>
<p>Be aware of two things here:</p>
<ul>
<li><code>unsafe</code> pointers are always scaled to the size of the type they refer to. <code>Unsafe.ByteOffset</code> returns the unscaled difference between two pointers. Thus explaining the division by the size in below sample. Scaling is not required if the type the pointers refer to are bytes.</li>
<li>Calculating the difference of two pointers requires you to pass them to <code>Unsafe.ByteOffset</code> in the opposite order as you would for the subtraction.</li>
</ul>
<pre class="language-c"><code class="language-c"><span class="token keyword">int</span> diff <span class="token operator">=</span> ptr2 <span class="token operator">-</span> ptr1<span class="token punctuation">;</span></code></pre>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">int</span></span> diff <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Unsafe<span class="token punctuation">.</span><span class="token function">ByteOffset</span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr1<span class="token punctuation">,</span> <span class="token keyword">ref</span> ptr2<span class="token punctuation">)</span> <span class="token operator">/</span> Unsafe<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">SizeOf</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2>Copy data from one reference to another</h2>
<p>The <code>Unsafe.CopyBlockUnaligned</code> method can be used to copy data from one location to another. Be aware, however, that this method only operates on byte references. You may have to</p>
<ul>
<li>reinterpret your <code>int</code> reference as a <code>byte</code> reference using <code>Unsafe.As&lt;int, byte&gt;(ref ptr)</code> and</li>
<li>scale the number of items you want to copy to bytes using <code>i * Unsafe.SizeOf&lt;int&gt;()</code>.</li>
</ul>
<p>Both points can be ignored if you are already working with <code>byte</code> references.</p>
<p>If you are certain that both references are aligned (point to an address that is a multiple of the platform-specific alignment), you can use the faster <code>Unsafe.CopyBlock</code>. This is always the case if both references point to the start of an array. Otherwise, it depends on the position and the platform the code is running on: The alignment of the different platforms small and large object heaps are given as follows (referring again to <a href="https://prodotnetmemory.com/" title="Pro .NET Memory Management - Konrad Kokosa">Pro .NET Memory Management by Konrad Kokosa</a>):</p>
<table>
<thead>
<tr>
<th>Platform</th>
<th>SOH</th>
<th>LOH</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>32-bit</strong></td>
<td>4 byte</td>
<td>8 byte</td>
</tr>
<tr>
<td><strong>64-bit</strong></td>
<td>8 byte</td>
<td>8 byte</td>
</tr>
</tbody>
</table>
<p>Now without further ado, the samples:</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token operator">*</span>ptr1<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>ptr2<span class="token operator">++</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">Unsafe<span class="token punctuation">.</span><span class="token function">CopyBlockUnaligned</span><span class="token punctuation">(</span><br>    <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">As</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr1<span class="token punctuation">)</span><span class="token punctuation">,</span> <br>    <span class="token keyword">ref</span>  Unsafe<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">As</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr2<span class="token punctuation">)</span><span class="token punctuation">,</span> <br>    <span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> Unsafe<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">SizeOf</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2>Initializing a block of data</h2>
<p>Just as above &quot;<code>memcpy</code> equivalent&quot; we also get a &quot;<code>memset</code> equivalent&quot; with <code>Unsafe</code>. The methods in question are named <code>Unsafe.InitBlock</code> and <code>Unsafe.InitBlockUnaligned</code>. The principles introduced in the last chapter regarding pointer scaling and alignment are true for this set of methods as well.</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token operator">*</span>ptr1<span class="token operator">++</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<pre class="language-csharp"><code class="language-csharp">Unsafe<span class="token punctuation">.</span><span class="token function">InitBlockUnaligned</span><span class="token punctuation">(</span><br>    <span class="token keyword">ref</span> Unsafe<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">As</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> ptr1<span class="token punctuation">)</span><span class="token punctuation">,</span> <br>    <span class="token number">0x42</span><span class="token punctuation">,</span> <br>    <span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> Unsafe<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">SizeOf</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2>Safety considerations</h2>
<p>Make absolutely sure you never keep a reference to memory location, that does not correspond to an obejct tracked by the GC. As an example; if you keep a reference to the element right after (out of bounds) an array, the GC can and will move that array without updating your reference!</p>
<blockquote>
<p>Feel free to leave feedback, comments and questions on <a href="https://www.reddit.com/r/dotnet/comments/akc1vv/unsafe_array_access_and_pointer_arithmetics_in_c/" title="Reddit Post for this Blog Post">reddit</a></p>
</blockquote>

                </article>
            </main>
        </div>
        <footer>
            <p>&#169; Nicolas Portmann</p>
        </footer>
    </body>
</html>