<!DOCTYPE html><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>An io_uring based Transport Layer (Part II) - Foundation</title>
        <meta name="description" content="A Software Engineering Blog">
        <meta property="og:url" content="https://ndportmann.com/io_uring-foundation/">
        <meta property="og:title" content="An io_uring based Transport Layer (Part II) - Foundation">
        <meta property="og:description" content="A blog about software engineering and applied cryptography.">
        <meta property="og:type" content="article">
        <meta name="twitter:site" content="@tkp1n">
        <meta name="twitter:creator" content="@tkp1n">
        <meta name="twitter:card" content="summary">
        <style>
            
            /*! tailwindcss v2.1.1 | MIT License | https://tailwindcss.com *//*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */*,::after,::before{box-sizing:border-box}:root{-moz-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Consolas,'Liberation Mono',Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}button{background-color:transparent;background-image:none}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}body{font-family:inherit;line-height:inherit}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}:root{--size-0_5:0.125rem;--size-1:0.250rem;--size-1_5:0.375rem;--size-2:0.5rem;--size-3:0.75rem;--size-3_5:0.875rem;--size-4:1rem;--size-4_5:1.125rem;--size-5:1.25rem;--size-6:1.5rem;--size-7:1.75rem;--size-7_5:1.875rem;--size-8:2rem;--size-9:2.25rem;--size-10:2.5rem;--size-xs:20rem;--size-md:28rem;--weight-extralight:200;--weight-light:300;--weight-bitbold:400;--weight-semibold:600;--blue-500:rgba(59, 130, 246, 1);--blue-600:rgba(37, 99, 235, 1);--blue-800:rgba(37, 99, 235, 1);--white:rgba(255, 255, 255, 1);--gray-200:rgba(229, 231, 235, 1);--gray-500:rgba(107, 114, 128, 1);--gray-800:rgba(31, 41, 55, 1);--black:rgba(0, 0, 0, 1)}*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.max-w-screen-lg{max-width:1024px}.max-w-screen-md{max-width:768px}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.mx-auto{margin-left:auto;margin-right:auto}.shadow{--tw-shadow:0 1px 3px 0 rgba(0, 0, 0, 0.1),0 1px 2px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.rounded{border-radius:.25rem}h2{font-size:var(--size-5);line-height:var(--size-7);margin-left:var(--size-4);margin-top:var(--size-6)}@media (min-width:1024px){h2{font-size:var(--size-6);line-height:var(--size-8)}}h3{font-size:var(--size-4_5);line-height:var(--size-7);margin-top:var(--size-6);color:var(--gray-800);font-weight:var(--weight-semibold);letter-spacing:-.025em}@media (min-width:1024px){h3{font-size:var(--size-5);line-height:var(--size-7)}}h4{margin-top:var(--size-5);font-weight:var(--weight-semibold)}.icon{width:var(--size-5);height:var(--size-5);margin-bottom:var(--size-1);display:inline}.tag{padding-right:var(--size-3);white-space:nowrap}pre{border-radius:var(--size-1)}ul{list-style:disc;padding-left:var(--size-4_5)}ol{list-style:decimal;padding-left:var(--size-4_5)}blockquote{margin-top:1rem;padding-left:1rem;border-left:4px solid #dadada}th{text-align:start;font-weight:var(--weight-bitbold)}code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:0 0;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#8292a2}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.header h1{margin-top:0;font-size:var(--size-4_5);line-height:var(--size-7)}@media(min-width:1024px){.header h1{font-size:var(--size-5)}}.sub{font-size:var(--size-4);line-height:var(--size-6);font-weight:var(--weight-extralight);height:var(--size-6)}.sub span{animation:fade 10s linear infinite 0s;opacity:0;overflow:hidden;position:absolute}.sub span:nth-child(2){animation-delay:2.5s}.sub span:nth-child(3){animation-delay:5s}.sub span:nth-child(4){animation-delay:7.5s}@media(min-width:1024px){.sub{font-size:var(--size-4_5);line-height:var(--size-7)}}@keyframes fade{0%{opacity:0}5%{opacity:0}10%{opacity:1}25%{opacity:1}30%{opacity:0}100%{opacity:0}}.outer{margin-top:var(--size-8);background-color:var(--blue-600);transform:skewY(6deg);width:66.666667%;max-width:var(--size-xs);min-width:-webkit-min-content;min-width:min-content}@media(min-width:1024px){.outer{max-width:var(--size-md)}}.inner{padding:var(--size-2);background-color:var(--white);transform:skewY(-6deg);width:80%}header>h1{font-size:var(--size-6);line-height:var(--size-8);margin-top:var(--size-7)}@media(min-width:1024px){header>h1{font-size:var(--size-7);line-height:var(--size-9)}}h1,h2,h3,h4,h5,h6{margin-left:0}.content{max-width:768px;margin-top:var(--size-6);padding-right:var(--size-5);padding-left:var(--size-5)}.text{margin-top:var(--size-2);font-size:var(--size-4)}.text p{padding-top:var(--size-4)}.text a{color:var(--blue-600)}.text a:hover{text-decoration:underline}.text pre{margin-top:var(--size-1);margin-bottom:var(--size-1)}.text table{table-layout:auto;width:100%;margin-top:var(--size-2);margin-bottom:var(--size-2)}.text tr{border-bottom-width:1px}.text td{padding:var(--size-1_5)}:not(a)>code{border-radius:var(--size-1);padding:var(--size-0_5);background-color:var(--gray-200)}.text blockquote>p{padding-top:0}footer{padding-top:var(--size-4);padding-bottom:var(--size-2);width:100%;text-align:center}
        </style>
        <link rel="stylesheet" href="../prism-okaidia.min.css">
        <link rel="stylesheet" href="../katex.min.css">
    </head>
    <body>
        <a href="/" class="header">
            <div class="outer shadow rounded mx-auto">
                <div class="inner shadow rounded mx-auto">
                    <header>
                        <h1>Nicolas Portmann</h1>
                        <div class="sub">
                            <span>Software Engineering</span>
                            <span>Security Engineering</span>
                            <span>Applied Cryptography</span>
                            <span>Performance Optimization</span>
                        </div>
                    </header>
                </div>
            </div>
        </a>
        <div class="content container mx-auto">
            <main>
                <header>
                    <h1>An io_uring based Transport Layer (Part II) - Foundation</h1>
                    
                    
    <section>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            <span class="meta">2020/02/07</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
            </svg>
            <span class="meta">Nicolas Portmann</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0
                        014-4z"></path>
            </svg>
            <span class="meta">io_uring</span>
        </span>
    </section>

                </header>
                <article class="text">
                    <p>In this series, we are going to explore what it takes to develop an <code>io_uring</code>-based Transport layer for .NET. In this episode, we introduce the <code>IoUring</code>-library - the foundation on which we shall build our Transport layer.</p>
<p>Make sure to check out the <a href="https://ndportmann.com/io_uring-rationale/" title="io_uring Rationale - ndportmann.com">previous episode</a> in this series, where we talked about what a .NET Transport layer is, and why we should build a new one.
If you are already familiar with the basics of Linux network programming and <code>IoUring</code>s native counterpart <code>liburing</code>, by all means, skip this episode and come back for the next one, once it's ready.</p>
<h2>Linux Network Programming Fundamentals</h2>
<p>This chapter is a <strong>very</strong> high-level overview and over-simplification of the syscalls traditionally involved in writing TCP client/server code. I highly recommend the books by Richard Stevens (e.g., <a href="https://www.amazon.com/dp/0131411551/ref=cm_sw_em_r_mt_dp_U_kNepEbW5QN4R0" title="UNIX Network Programming - Richard Stevens - amazon.com">UNIX Network Programming</a>), if you want to dig deeper.</p>
<p>It typically all starts with a call to <code>socket</code>. We specify the family, type, and protocol of the I/O we want to perform and receive a socket file descriptor in return. Remember, everything in Linux is a file.</p>
<h3>Server-Side</h3>
<p>A TCP server continues by calling <code>bind</code>, to assign the socket to an address (port) on the server. Once bound to a port, the server can start to <code>listen</code> with the next syscall. When calling <code>listen</code>, the server specifies the number of pending incoming connections it wants to queue up. A call to <code>accept</code> returns an actual client connection, once a client tries to connect to the server. The file descriptor returned by <code>accept</code> is later used to exchange data with the client.</p>
<h3>Client-Side</h3>
<p>On the client-side, things are uncomplicated. Once we have a socket, obtained through the equally named syscall, we can <code>connect</code> directly to a server by specifying its address.</p>
<h3>Exchanging Data</h3>
<p>Syscalls like <code>read</code> (and co.) receive data, while their <code>write</code> counterparts send data across the socket. It all ends, once one party calls <code>close</code> to terminate the connection.</p>
<h2>Non-blocking Sockets and Polling</h2>
<p>Without modification, the above syscalls are all blocking the calling thread. Blocking means that the invoked functions only return once the requested operation completed. For example, <code>accept</code> only returns once a client connects to the server. While these syscalls are doing their thing, the thread calling it is blocked and cannot do anything else. It turns out this is rather inefficient, as threads are still a valuable resource that we should use as efficiently as possible.</p>
<p>Non-blocking options were added to the syscalls mentioned above to mitigate this inefficiency. With those options enabled, the syscalls return immediately. Even if the requested operation is still in progress, we can, therefore, start multiple socket operations using the same thread and use a polling and waiting mechanism to check and wait for the requested operations to complete. The best way to perform this polling and waiting <em>was</em> the <code>epoll</code> interface. <em>Was</em> because, with <code>io_uring</code>, we now have an even better option at hand.</p>
<p>Describing the <code>epoll</code> interface in detail is too much for the scope of this episode. Since we aren't using it in our endeavor, this shouldn't matter too much.</p>
<h2>Reducing the Number of Syscalls</h2>
<p>In <a href="https://ndportmann.com/io_uring-rationale/" title="io_uring Rationale - ndportmann.com">the last episode</a>, we established some levers we can pull to optimize the performance of networking code. One of those is the reduction of syscalls. The rationale behind this is the cost associated with invoking syscalls. Again, check out the <a href="https://ndportmann.com/io_uring-rationale/" title="io_uring Rationale - ndportmann.com">previous episode</a> for more details on this.</p>
<p>The community introduced <code>libaio</code> (AIO) to tackle this problem. The new syscalls behind AIO can be used to submit multiple socket operations at once (<code>io_submit</code>) and to get the results for completed operations with another syscall <code>io_getevents</code>. Unfortunately, AIO didn't solve all our problems. <code>io_submit</code> can (sometimes) block, and performance overall isn't great. See this <a href="https://www.youtube.com/watch?v=-5T4Cjw46ys" title="Faster IO through io_uring - Jens Axboe - YouTube">presentation from Jens Axboe</a> for more hints in this direction.</p>
<h2>Enter <code>io_uring</code></h2>
<blockquote>
<p>DISCLAIMER: This post covers parts of the <code>io_uring</code> API surface that shipped with kernel version 5.4. It grew a lot since then, but by the time of writing, 5.4 is LTS.</p>
</blockquote>
<p>Jens Axboe introduced <code>io_uring</code> to solve a multitude of issues around non-blocking, fast, and parallel I/O with few syscalls. &quot;One API to rule them all&quot; so to say. <code>io_uring</code> consists of two ring buffers (hence the name): a submission queue and a completion queue. The application writes I/O operations to the submission queue, which the kernel consumes and executes. The kernel, on the other hand, writes the results of the completed I/O operations to the completion queue, which the application consumes and inspects. There is no &quot;syscall-tax&quot; per submission or completion because the memory behind the two queues is shared between the kernel and the application. Setting up an <code>io_uring</code>-instance is, therefore, relatively involved.</p>
<h3>Setup</h3>
<p>The syscall <code>io_uring_setup</code> allows us to specify the desired size of the submission queue. The kernel adjusts this number to the next power of two, given it isn't already chosen as such. The kernel, in turn, defines the size of the completion queue to be twice as large as the submission queue by default, although the user can overwrite this.</p>
<h4>Completion Queue Size and Overflows</h4>
<p>The completion queue should be larger than the submission queue to ensure there is enough space for queued up operations to complete &quot;at the same time&quot;. Newer kernel versions (&gt; 5.5.) have an internal buffer to avoid completion queue overflows. On platforms where this feature is lacking, the application has to take care that no more I/O operations are in flight than fit the completion queue.</p>
<h4>I/O Polling</h4>
<p>I/O in the Linux kernel usually is interrupt-driven. In interrupt mode, the I/O device notifies the kernel via a so-called interrupt about the completion of I/O operations. With <code>io_uring</code>, we have the option to enable I/O polling (a privileged operation). Interrupt driven I/O is more efficient for most workloads, as it prevents the kernel from wasting CPU cycles by polling for I/O operations that are still pending.</p>
<h4>Submission Queue Polling</h4>
<p>Typically, the user application must notify the kernel about I/O operations added to the submission queue. <code>io_uring</code> offers the privileged option to enable submission queue polling. In this mode, the kernel polls the submission Queue until a configurable time-out. Should the time-out occur, the kernel falls back to the normal mode where the application must notify the kernel about submissions.</p>
<h4>The C# API - Constructor</h4>
<p>Behind the scenes, the setup of an <code>io_uring</code> instance is relatively complicated. It includes not only the call to <code>io_uring_setup</code> but also multiple <code>mmap</code>s to get access to the shared memory behind the two ring buffers. All of this complexity is handled for you by the constructor of the <code>Ring</code> class introduced in <a href="https://github.com/tkp1n/IoUring" title="IoUring - GitHub"><code>IoUring</code></a>. Given the explanation of the various options above, the following two samples are hopefully fairly self-explanatory.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> ioUringDefault <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Ring</span><span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token class-name"><span class="token keyword">var</span></span> ioUringCrazy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Ring</span><span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">RingOptions</span><br><span class="token punctuation">{</span><br>    CompletionQueueSize <span class="token operator">=</span> <span class="token number">4096</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span><br>    EnablePolledIo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>    EnableSubmissionPolling <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>    PollingThreadIdleAfter <span class="token operator">=</span> TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    SubmissionQueuePollingCpuAffinity <span class="token operator">=</span> <span class="token number">1</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>All settings can be queried as public properties on the <code>Ring</code> instance. The most interesting one is the size of the completion queue, as it is set by the kernel.</p>
<h4>A Word of Warning: ENOMEM</h4>
<p>On most Linux distributions, the limit on the locked bytes of memory is set relatively low. This leads to errors (<code>ENOMEM</code>), even when creating small rings. To adjust this limit, increase the configuration of the value <code>RLIMIT_MEMLOCK</code>. How this is done exactly depends on your distribution. Please refer to the <a href="https://github.com/tkp1n/IoUring#setting-proper-resource-limits-rlimit_memlock" title="README.md - IoUring - GitHub">README</a> of <code>IoUring</code> for a starting point on how this is achieved.</p>
<h3>Prepare I/O Operations</h3>
<p>Before I/O operations can be submitted to the kernel for execution, they need to be prepared. Preparing an I/O operation is relatively cheap and done by copying some pointers and flags. It neither includes a syscall, nor a memory-barrier. The number of I/O operations that can be prepared without submitting them is limited by the size of the ring (or, more specifically, the submission queue size) set during its construction.</p>
<p>It is generally desirable to prepare as many I/O operations as possible before submitting them. Submitting the prepared operations includes at least a memory-barrier when in polling mode and additionally a syscall in &quot;normal mode&quot;.</p>
<p>To get an overview over the I/O operations supported by <code>io_uring</code>, please refer to the LWN article <a href="https://lwn.net/Articles/810414/" title="The rapid growth of io_uring - lwn.net">&quot;The rapid growth of io_uring&quot;</a>. I couldn't do much more than copying Jonathan's statements there.</p>
<h4>User data</h4>
<p>Each I/O operation carries 64-bits of user data. This user data is read by the kernel and routed through to the completion queue entry. This allows the application to establish a context between a submission and a completion.</p>
<h4>Submit Options</h4>
<p>Various options can be set with each I/O operation to control how it is executed:</p>
<ul>
<li><code>IOSQE_IO_DRAIN</code> - execute this operation once all other pending operations are completed.</li>
<li><code>IOSQE_IO_LINK</code> - execute this and all following operations with this flag set in the order they were submitted.</li>
<li>... additional options were introduced after kernel version 5.4 - not discussed here.</li>
</ul>
<h4>The C# API - PrepareXXX</h4>
<p>Let's have a look at how some of the supported I/O operations can be prepared using the C# API:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Ring</span><span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Prepare a no-op with the drain option set</span><br>r<span class="token punctuation">.</span><span class="token function">PrepareNop</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">userData</span><span class="token punctuation">:</span> <span class="token number">42UL</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">options</span><span class="token punctuation">:</span> SubmissionOption<span class="token punctuation">.</span>Drain<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Prepare a 'readv' on the file descriptor fd using nrOfIovecs iovecs</span><br>r<span class="token punctuation">.</span><span class="token function">PrepareReadV</span><span class="token punctuation">(</span>fileDescriptor<span class="token punctuation">,</span> iovecs<span class="token punctuation">,</span> nrOfIovecs<span class="token punctuation">,</span> <span class="token named-parameter punctuation">userData</span><span class="token punctuation">:</span> <span class="token number">43UL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Add a one-shot poll for POLLIN on the given socket file descriptor</span><br>r<span class="token punctuation">.</span><span class="token function">PreparePollAdd</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">ushort</span><span class="token punctuation">)</span> POLLIN<span class="token punctuation">,</span> <span class="token named-parameter punctuation">userData</span><span class="token punctuation">:</span> <span class="token number">44UL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3>Submit and Reap Completions</h3>
<p>We learned how to create a <code>Ring</code> and prepare I/O operations. All we need now is a way to make the kernel aware of the prepared submissions and to check for, or wait for completions.</p>
<h4>The C# API - Submit &amp; Flush</h4>
<pre class="language-csharp"><code class="language-csharp"><br><span class="token comment">// Submit all prepared operations</span><br><span class="token class-name"><span class="token keyword">var</span></span> nofSubmittedOps <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">Submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Flush all submitted operations and block until 1 completed</span><br><span class="token class-name"><span class="token keyword">var</span></span> nofFlushedOps <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span>nofSubmittedOps<span class="token punctuation">,</span> <span class="token named-parameter punctuation">minComplete</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>That's it.</p>
<p>The <code>Submit</code> helper method introduces a memory-barrier so that the kernel has a chance to see what we've prepared for it. If the kernel is in polling mode, a call to submit is enough, given the polling time-out hasn't triggered yet. <code>Flush</code> is an intelligent wrapper around the syscall <code>io_uring_enter</code> that is responsible for both making the kernel aware of the submitted items but also to reap the completions that happened since the last call. It is intelligent, because if the kernel is in the polling mode, the syscall is only made if the kernel currently isn't &quot;sleeping&quot; after a time-out. If polling is not enabled, <code>Flush</code> always calls <code>io_uring_enter</code>. The second, optional parameter is the number of completions to await. If this parameter is set to <code>0</code>, the call does not block.</p>
<p>Note that even with <code>minComplete</code> set to <code>0</code> <code>Flush</code> could take a while, as most submitted operations are started during the invocation and, if possible without blocking, completed synchronously.</p>
<p>This is the most exciting feature of <code>io_uring</code>. One syscall to:</p>
<ul>
<li>Submit multiple I/O operations</li>
<li>Complete all operations that can be completed synchronously without blocking</li>
<li>Get the result of all operations that completed since the last call</li>
</ul>
<h3>Inspect Completions</h3>
<p>Completions are straightforward. A struct, two members. The user data provided when preparing the operation that completed and its result. If the result is negative, it is the &quot;negative errno&quot; that lead to the error. Non-negative results can be considered a successful completion of the I/O operation.</p>
<h4>The C# API - Completions</h4>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name">Completion</span> c <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><br><span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">TryRead</span><span class="token punctuation">(</span><span class="token keyword">ref</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ErrnoException</span><span class="token punctuation">(</span><span class="token operator">-</span>c<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"I/O operation </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">c<span class="token punctuation">.</span>userData</span><span class="token punctuation">}</span></span><span class="token string"> completed"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"successfully with result: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">c<span class="token punctuation">.</span>result</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h2>Summary</h2>
<p>The Linux network and I/O APIs have evolved drastically over the years. What started with some simple syscalls quickly became a hard to navigate landscape of async options and functions. <code>io_uring</code> promises to simplify things again for network developers. Just a couple of syscalls, easily wrapped and hidden behind a library like <code>liburing</code> or <code>IoUring</code> enable us to quickly write high-performance networking code.</p>
<p>Stay tuned for more episodes on this topic and check out the <a href="https://github.com/tkp1n/IoUring" title="IoUring - GitHub"><code>IoUring</code></a> repository, where we build next network Transport layer for .NET. If you want to get involved, there are a couple of open issues waiting for eager contributors ðŸ˜‰.</p>

                </article>
            </main>
        </div>
        <footer>
            <p>&#169; Nicolas Portmann</p>
        </footer>
    </body>
</html>