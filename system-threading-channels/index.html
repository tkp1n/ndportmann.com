<!DOCTYPE html><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Exploring System.Threading.Channels</title>
        <meta name="description" content="A Software Engineering Blog">
        <meta property="og:url" content="https://ndportmann.com/system-threading-channels/">
        <meta property="og:title" content="Exploring System.Threading.Channels">
        <meta property="og:description" content="A blog about software engineering and applied cryptography.">
        <meta property="og:type" content="article">
        <meta name="twitter:site" content="@tkp1n">
        <meta name="twitter:creator" content="@tkp1n">
        <meta name="twitter:card" content="summary">
        <style>
            
            /*! tailwindcss v2.1.1 | MIT License | https://tailwindcss.com *//*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */*,::after,::before{box-sizing:border-box}:root{-moz-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Consolas,'Liberation Mono',Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}button{background-color:transparent;background-image:none}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}body{font-family:inherit;line-height:inherit}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}:root{--size-0_5:0.125rem;--size-1:0.250rem;--size-1_5:0.375rem;--size-2:0.5rem;--size-3:0.75rem;--size-3_5:0.875rem;--size-4:1rem;--size-4_5:1.125rem;--size-5:1.25rem;--size-6:1.5rem;--size-7:1.75rem;--size-7_5:1.875rem;--size-8:2rem;--size-9:2.25rem;--size-10:2.5rem;--size-xs:20rem;--size-md:28rem;--weight-extralight:200;--weight-light:300;--weight-bitbold:400;--weight-semibold:600;--blue-500:rgba(59, 130, 246, 1);--blue-600:rgba(37, 99, 235, 1);--blue-800:rgba(37, 99, 235, 1);--white:rgba(255, 255, 255, 1);--gray-200:rgba(229, 231, 235, 1);--gray-500:rgba(107, 114, 128, 1);--gray-800:rgba(31, 41, 55, 1);--black:rgba(0, 0, 0, 1)}*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.max-w-screen-lg{max-width:1024px}.max-w-screen-md{max-width:768px}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.mx-auto{margin-left:auto;margin-right:auto}.shadow{--tw-shadow:0 1px 3px 0 rgba(0, 0, 0, 0.1),0 1px 2px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.rounded{border-radius:.25rem}h2{font-size:var(--size-5);line-height:var(--size-7);margin-left:var(--size-4);margin-top:var(--size-6)}@media (min-width:1024px){h2{font-size:var(--size-6);line-height:var(--size-8)}}h3{font-size:var(--size-4_5);line-height:var(--size-7);margin-top:var(--size-6);color:var(--gray-800);font-weight:var(--weight-semibold);letter-spacing:-.025em}@media (min-width:1024px){h3{font-size:var(--size-5);line-height:var(--size-7)}}h4{margin-top:var(--size-5);font-weight:var(--weight-semibold)}.icon{width:var(--size-5);height:var(--size-5);margin-bottom:var(--size-1);display:inline}.tag{padding-right:var(--size-3);white-space:nowrap}pre{border-radius:var(--size-1)}ul{list-style:disc;padding-left:var(--size-4_5)}ol{list-style:decimal;padding-left:var(--size-4_5)}blockquote{margin-top:1rem;padding-left:1rem;border-left:4px solid #dadada}th{text-align:start;font-weight:var(--weight-bitbold)}code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:0 0;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#8292a2}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.header h1{margin-top:0;font-size:var(--size-4_5);line-height:var(--size-7)}@media(min-width:1024px){.header h1{font-size:var(--size-5)}}.sub{font-size:var(--size-4);line-height:var(--size-6);font-weight:var(--weight-extralight);height:var(--size-6)}.sub span{animation:fade 10s linear infinite 0s;opacity:0;overflow:hidden;position:absolute}.sub span:nth-child(2){animation-delay:2.5s}.sub span:nth-child(3){animation-delay:5s}.sub span:nth-child(4){animation-delay:7.5s}@media(min-width:1024px){.sub{font-size:var(--size-4_5);line-height:var(--size-7)}}@keyframes fade{0%{opacity:0}5%{opacity:0}10%{opacity:1}25%{opacity:1}30%{opacity:0}100%{opacity:0}}.outer{margin-top:var(--size-8);background-color:var(--blue-600);transform:skewY(6deg);width:66.666667%;max-width:var(--size-xs);min-width:-webkit-min-content;min-width:min-content}@media(min-width:1024px){.outer{max-width:var(--size-md)}}.inner{padding:var(--size-2);background-color:var(--white);transform:skewY(-6deg);width:80%}header>h1{font-size:var(--size-6);line-height:var(--size-8);margin-top:var(--size-7)}@media(min-width:1024px){header>h1{font-size:var(--size-7);line-height:var(--size-9)}}h1,h2,h3,h4,h5,h6{margin-left:0}.content{max-width:768px;margin-top:var(--size-6);padding-right:var(--size-5);padding-left:var(--size-5)}.text{margin-top:var(--size-2);font-size:var(--size-4)}.text p{padding-top:var(--size-4)}.text a{color:var(--blue-600)}.text a:hover{text-decoration:underline}.text pre{margin-top:var(--size-1);margin-bottom:var(--size-1)}.text table{table-layout:auto;width:100%;margin-top:var(--size-2);margin-bottom:var(--size-2)}.text tr{border-bottom-width:1px}.text td{padding:var(--size-1_5)}:not(a)>code{border-radius:var(--size-1);padding:var(--size-0_5);background-color:var(--gray-200)}.text blockquote>p{padding-top:0}footer{padding-top:var(--size-4);padding-bottom:var(--size-2);width:100%;text-align:center}
        </style>
        <link rel="stylesheet" href="../prism-okaidia.min.css">
        <link rel="stylesheet" href="../katex.min.css">
    </head>
    <body>
        <a href="/" class="header">
            <div class="outer shadow rounded mx-auto">
                <div class="inner shadow rounded mx-auto">
                    <header>
                        <h1>Nicolas Portmann</h1>
                        <div class="sub">
                            <span>Software Engineering</span>
                            <span>Security Engineering</span>
                            <span>Applied Cryptography</span>
                            <span>Performance Optimization</span>
                        </div>
                    </header>
                </div>
            </div>
        </a>
        <div class="content container mx-auto">
            <main>
                <header>
                    <h1>Exploring System.Threading.Channels</h1>
                    
                    
    <section>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            <span class="meta">2019/01/03</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
            </svg>
            <span class="meta">Nicolas Portmann</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0
                        014-4z"></path>
            </svg>
            <span class="meta">.NET</span>
        </span>
    </section>

                </header>
                <article class="text">
                    <p>The <code>System.Threading.Channels</code> namespace provides data structures (stores) for pub/sub scenarios. It enables you to decouple one-to-many publishers from one-to-many subscribers just as its equally named counterpart from <a href="https://tour.golang.org/concurrency/2" title="golang - Concurrency - Channels">go</a>.</p>
<p>At first glance, this might look similar to the functionality provided by <code>BufferBlock&lt;T&gt;</code> from <code>System.Threading.Task.Dataflow</code>. <code>Channels</code>, however, are a more low-level primitive upon which libraries such as <code>Dataflow</code> can be built. If <code>Dataflow</code> was still in development today, it would most certainly be based on <code>Channels</code> to some extent.</p>
<h2>Bounded vs. Unbounded Channels</h2>
<p>Channels are created using the static factory methods of the <code>Channel</code> class.
The type parameter <code>T</code> is used to identify the type of object that can be passed from a publisher to a subscriber via the created <code>Channel</code>.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Channel<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">CreateBounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Channel<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">CreateBounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">BoundedChannelOptions</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Channel<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">CreateUnbounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Channel<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">CreateUnbounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">UnboundedChannelOptions</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<p>Using <code>CreateUnbounded</code> creates a channel that can accept an infinite amount of messages - given an endless amount of memory of course. The unbounded channel variant is more performant than its bounded counterpart in almost every benchmark (see below). This win in performance comes at the cost of potentially running out of memory. If you can externally guarantee, that the channel never contains more then a certain amount of pending objects, using an unbounded channel is profitable. Otherwise, it is more secure to rely on bounded channels.</p>
<p>Bounded channels operate in one of four <code>FullMode</code>s, which can be set via the options parameter to the <code>CreateBounded</code> factory method.</p>
<pre class="language-csharp"><code class="language-csharp">Channel<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">CreateBounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">BoundedChannelOptions</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    FullMode <span class="token operator">=</span> BoundedChannelFullMode<span class="token punctuation">.</span>Wait<br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The four supported <code>FullMode</code>s are:</p>
<ul>
<li><code>Wait</code> - Wait for space to be available in order to complete the write operation.</li>
<li><code>DropNewest</code> - Remove and ignore the newest item in the channel in order to make room for the item being written.</li>
<li><code>DropOldest</code> - Remove and ignore the oldest item in the channel in order to make room for the item being written.</li>
<li><code>DropWrite</code> - Drop the item being written.</li>
</ul>
<p>Be aware that the most convenient option <code>Wait</code> might also cause memory issues, as each asynchronously 'waiting' producer requires memory as well.</p>
<h2>Publisher / Subscriber cardinality</h2>
<p>Channels are assumingly used to coordinate one publisher with the computing power of multiple subscribers, or to fit the work of multiple producers through the bottleneck of a single consumer. It is however also possible to model multi-publisher / multi-subscriber or single-publisher / single-subscriber scenarios using channels.</p>
<p>To notify the factory methods of the specific scenario at hand, two properties on both the <code>Unbounded</code>- and the <code>BoundedChannelOptions</code> can be set accordingly.</p>
<pre class="language-csharp"><code class="language-csharp">Channel<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">CreateUnbounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">UnboundedChannelOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    SingleWriter <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span><br>    SingleReader <span class="token operator">=</span> <span class="token boolean">true</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The documentation for those two properties indicates, that specific optimizations may be unlocked if the channel knowns about the single-reader or single-writer guarantee. This information is currently used to determine the appropriate <code>Channel</code> implementation for the given circumstances. The CoreFX repository contains three implementations of the abstract <code>Channel&lt;T&gt;</code> class; a bounded Channel, a single-reader and a multi-reader unbounded channel. Unless specifying a single-consumer scenario to the unbounded channel factory, there is currently no effect in setting those properties. It is nevertheless considered best-practice, as more optimizations might be added in the future.</p>
<h2>Synchronous Continuations</h2>
<p>You may have heard of <code>TaskCreationOptions.RunContinuationsAsynchronously</code> which was added in .NET Framework 4.6. It forces continuations of tasks to be executed asynchronously (e.g., on the thread pool). The critical thing to note here is that this behavior is not the default. In other words, continuations are executed synchronously per default by the thread that provides the result of a task (e.g., executes <code>TrySetResult</code> on the <code>TaskCompletionSource</code>). Synchronous execution typically helps with performance but may trigger nasty deadlocks, as developers may not be aware of which thread is executing the continuations.</p>
<p>With <code>Channels</code>, this default changed. Not globally of course, but for continuations registered inside the <code>Channel</code>. Asynchronous execution ensures, that a producer thread does not end up doing consumer work when executing a continuation synchronously. If you are sure, that this added safety is not necessary in your specific use case, it can be turned off using another boolean property in the <code>Channel</code>s options, which defaults to false. Doing so most likely increases throughput but reduces concurrency.</p>
<pre class="language-csharp"><code class="language-csharp">Channel<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">CreateUnbounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">UnboundedChannelOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    AllowSynchronousContinuations <span class="token operator">=</span> <span class="token boolean">true</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2>Interacting with Channels</h2>
<p><code>Channel</code> (much as the <code>IDuplexPipe</code> interface from <code>System.IO.Pipelines</code>) exposes two properties. A <code>ChannelReader</code> and a <code>ChannelWriter</code>.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name">Channel<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> channel <span class="token operator">=</span> Channel<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">CreateUnbounded</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token class-name">ChannelReader<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> reader <span class="token operator">=</span> channel<span class="token punctuation">.</span>Reader<span class="token punctuation">;</span><br><span class="token class-name">ChannelWriter<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> writer <span class="token operator">=</span> channel<span class="token punctuation">.</span>Writer<span class="token punctuation">;</span></code></pre>
<p>The <code>ChannelReader</code> and the <code>ChannelWriter</code> feature a very symmetrical API (optional parameters removed for brevity):</p>
<table>
<thead>
<tr>
<th>ChannelReader</th>
<th>ChannelWriter</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool TryRead(out T item)</code></td>
<td><code>bool TryWrite(T item)</code></td>
</tr>
<tr>
<td><code>ValueTask&lt;T&gt; ReadAsync()</code></td>
<td><code>ValueTask WriteAsync(T item)</code></td>
</tr>
<tr>
<td><code>ValueTask&lt;bool&gt; WaitToReadAsync()</code></td>
<td><code>ValueTask&lt;bool&gt; WaitToWriteAsync()</code></td>
</tr>
<tr>
<td><code>Task Completion</code></td>
<td><code>bool TryComplete()</code>, <code>void Complete()</code></td>
</tr>
</tbody>
</table>
<p>It is obvious that the <code>ChannelWriter</code> can be used to write (publish) objects to the <code>Channel</code>, whereas the <code>ChannelReader</code> can be used to read (consume) them. It is also obvious that the writing side is in control of the completion of the <code>Channel</code>, while the readers can only observe the writers decision (e.g., via the <code>Completion</code> Task that completes, when the channel completes).</p>
<h3>TryRead / TryWrite</h3>
<p>These synchronous methods may be used to optimistically and synchronously read from or write to a <code>Channel</code>. (Note that writing synchronously to an unbounded <code>Channel</code> always succeeds unless the channel is closed.) This is typically used to avoid going asynchronous via the following pattern:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name">ValueTask</span> <span class="token function">PublishAsync</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">AsyncSlowPath</span><span class="token punctuation">(</span><span class="token class-name">T</span> thing<span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">await</span> channel<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span>thing<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">return</span> channel<span class="token punctuation">.</span><span class="token function">TryWrite</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token keyword">default</span> <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ValueTask</span><span class="token punctuation">(</span><span class="token function">AsyncSlowPath</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h3>ReadAsync / WriteAsync</h3>
<p>As indicated above, those two methods are the asynchronous counterparts to <code>TryRead</code> and <code>TryWrite</code>. The critical thing to note here is that both methods throw a <code>ChannelClosedException</code> (possibly containing an inner exception if one was passed as a parameter to <code>TryComplete</code> or <code>Complete</code>) if the <code>Channel</code> is completed during the operation. If you can live with a <code>try</code>/<code>catch</code>-block or externally guarantee, that the channel will not be completed during reads or writes, these two methods are for you. Otherwise, the next pair of methods offers an elegant alternative.</p>
<h3>WaitToReadAsync / WaitToWriteAsync</h3>
<p><code>WaitToReadAsync</code> and <code>WaitToWriteAsyn</code> allow you to wait asynchronously until the <code>Channel</code> becomes readable/writable again. Note, that there is no guarantee, that the <code>Channel</code> will stay readable/writable, until you acutally read from / write to it. Both methods will not throw an exception if the channel is completed during the operation (unless you provide an exception to TryComplete or Complete, see below). In this case, they will simply return false. An appropriate usage pattern may be the following. In the case of an exception, it will not be wrapped in a <code>ChannelClosedException</code> (as with <code>ReadAsync</code> / <code>WriteAsync</code>) but thrown directly.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name">ValueTask<span class="token punctuation">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">></span></span> <span class="token function">PublishAsync</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">></span></span> <span class="token function">AsyncSlowPath</span><span class="token punctuation">(</span><span class="token class-name">T</span> thing<span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> channel<span class="token punctuation">.</span><span class="token function">WaitToWriteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>        <span class="token punctuation">{</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">TryWrite</span><span class="token punctuation">(</span>thing<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Channel was completed during the wait</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">return</span> channel<span class="token punctuation">.</span><span class="token function">TryWrite</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ValueTask<span class="token punctuation">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ValueTask<span class="token punctuation">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token function">AsyncSlowPath</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Note that <code>TryWrite</code> is now executed in a while-loop, as the <code>Channel</code> may no longer be writeable once we get to actually writing to it.</p>
<h3>Completion / TryComplete / Complete</h3>
<p>On the reader side, <code>Completion</code> can be used to execute code after the channel has been completed. This can be achieved by either awaiting the <code>Task</code> or by registering a continuation using <code>ContinueWith</code>. Another option for the reader is to query whether the channel is still active by calling <code>!channel.Completion.IsCompleted</code>. Note however that this information might already be outdated, one queried.</p>
<p>As already mentioned, the writing side is in control of <code>Channel</code> completion. Publishers can call <code>TryComplete</code> or <code>Complete</code> without parameter to indicate normal completion, or pass in an <code>Exception</code> to indicate completion due to an error. The only difference between <code>TryComplete</code> and <code>Complete</code> is that the latter will throw a <code>ChannelClosedException</code> if the channel is already closed, while to former will just return <code>false</code> in this case.</p>
<h3>Usage patterns</h3>
<p>The following text and usage patterns were taken from or inspired by the partially outdated <a href="https://github.com/dotnet/corefxlab/blob/31d98a89d2e38f786303bf1e9f8ba4cf5b203b0f/src/System.Threading.Tasks.Channels/README.md#example-producerconsumer-patterns" title="Channels README on GitHub">REDAME</a> from Stephen Toub. I took the liberty of updating them as the API has slightly changed since its corefxlab days.</p>
<h4>Producer patterns</h4>
<p>The simplest way to produce a bunch of numbers and complete might look like this:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ProduceRange</span><span class="token punctuation">(</span><span class="token class-name">ChannelWriter<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>If the <code>Channel</code> is expected to be unbounded or the need to wait unlikely, the loop may be optimized using <code>TryWrite</code> as indicated earlier:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ProduceRange</span><span class="token punctuation">(</span><span class="token class-name">ChannelWriter<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">TryWrite</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><br>        <span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>If returning a <code>ValueTask</code> is an option, going async can be avoided altogether if all writes complete synchronously with:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">ValueTask</span> <span class="token function">ProduceRange</span><span class="token punctuation">(</span><span class="token class-name">ChannelWriter<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">TryWrite</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><br><br>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ValueTask</span><span class="token punctuation">(</span><span class="token function">FinishProducingRange</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> i<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> <span class="token keyword">default</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">FinishProducingRangeAsync</span><span class="token punctuation">(</span><span class="token class-name">ChannelWriter<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> current<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> current<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>If you are uncertain, whether the <code>Channel</code> may be closed during the operation, the following pattern provides a more secure approach:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ProduceRange</span><span class="token punctuation">(</span><span class="token class-name">ChannelWriter<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">WaitForWriteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>        <span class="token punctuation">{</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">TryWrite</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>And if it's expected that most writers will succeed synchronously, it may be advantageous to also loop on the <code>TryWrite</code>, e.g:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ProduceRange</span><span class="token punctuation">(</span><span class="token class-name">ChannelWriter<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> count <span class="token operator">&amp;&amp;</span> <span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">WaitForWriteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> count <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span><span class="token function">TryWrite</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>The implementation of the variant that may return synchronously without allocating a Task is left as an exercise to the reader.</p>
<h4>Consumer patterns</h4>
<p>On the consuming end, there are similarly multiple ways to consume a channel. Which one is chosen will depend on the exact needs of the situation. A simple read-loop may look like this:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Consume</span><span class="token punctuation">(</span><span class="token class-name">ChannelReader<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">try</span><br>    <span class="token punctuation">{</span><br>         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><br>         <span class="token punctuation">{</span><br>             <span class="token class-name"><span class="token keyword">int</span></span> item <span class="token operator">=</span> <span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">ReadAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>             <span class="token comment">// process item...</span><br>         <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ChannelClosedException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p><code>WaitForReadAsync</code> and <code>TryRead</code> may also be used. This avoids the use of an exception to indicate if/when the channel has been closed, e.g.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Consume</span><span class="token punctuation">(</span><span class="token class-name">ChannelReader<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">WaitForReadAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">TryRead</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">int</span></span> item<span class="token punctuation">)</span><span class="token punctuation">)</span><br>        <span class="token punctuation">{</span><br>             <span class="token comment">// process item...</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>As with the writing example, if it's expected that waiting is relatively rare, a nested loop can be used to optimize for reads by looping over TryRead as well:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Consume</span><span class="token punctuation">(</span><span class="token class-name">ChannelReader<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">await</span> c<span class="token punctuation">.</span><span class="token function">WaitForReadAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">{</span><br>        <span class="token keyword">while</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">TryRead</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">int</span></span> item<span class="token punctuation">)</span><span class="token punctuation">)</span><br>        <span class="token punctuation">{</span><br>            <span class="token range operator">..</span><span class="token punctuation">.</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<h2>Summary</h2>
<p>System.Threading.Channels is a highly versatile library to orchestrate pub/sub scenarios in the .NET universe asynchronously.
It is fast enough, to dispatch well over 20 million messages in under a second and does not block any thread while doing so. It's blocking community counterpart <a href="https://github.com/disruptor-net/Disruptor-net" title="Disruptor-net on GitHub">Disruptor-net</a> is faster in some scenarios (compare the benchmarks below with their <a href="https://github.com/disruptor-net/Disruptor-net/wiki/Performance-Results" title="Performance Results from Disruptor-net on GitHub">performance results</a>).
I am currently using Channels to sequence the writes of multiple producers to a single <code>PipeWriter</code> (from <code>System.IO.Pipelines</code>), avoiding some calls to <code>pipeWriter.FlushAsync</code> if <code>channel.TryRead</code> returns true multiple times.</p>
<h2>Benchmarks</h2>
<blockquote>
<p>The source code for the benchmark for reproduction can be found <a href="https://github.com/tkp1n/ChannelPlayground" title="ChannelPlayground project on GitHub">here</a>. Be aware, that the Bounded channel was sized to be able to store all messages. If the channel were undersized, the benchmarks scores would look much worse.</p>
</blockquote>
<h3>Multi-Publisher / Multi-Subscriber</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>SyncCont.</th>
<th style="text-align:right">Mean (ms)</th>
<th style="text-align:right">Error (ms)</th>
<th style="text-align:right">StdDev (ms)</th>
<th style="text-align:right">Million messages / sec</th>
</tr>
</thead>
<tbody>
<tr>
<td>BoundedWait</td>
<td>False</td>
<td style="text-align:right">46.40</td>
<td style="text-align:right">0.8731</td>
<td style="text-align:right">0.8167</td>
<td style="text-align:right">21.55</td>
</tr>
<tr>
<td>BoundedWait</td>
<td>True</td>
<td style="text-align:right">45.22</td>
<td style="text-align:right">0.4662</td>
<td style="text-align:right">0.4361</td>
<td style="text-align:right">22.11</td>
</tr>
<tr>
<td>Unbounded</td>
<td>False</td>
<td style="text-align:right">41.07</td>
<td style="text-align:right">0.2820</td>
<td style="text-align:right">0.2638</td>
<td style="text-align:right">24.35</td>
</tr>
<tr>
<td>Unbounded</td>
<td>True</td>
<td style="text-align:right">42.13</td>
<td style="text-align:right">0.3960</td>
<td style="text-align:right">0.3704</td>
<td style="text-align:right">23.74</td>
</tr>
</tbody>
</table>
<h3>Multi-Publisher / Single-Subscriber</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>SyncCont.</th>
<th style="text-align:right">Mean (ms)</th>
<th style="text-align:right">Error (ms)</th>
<th style="text-align:right">StdDev (ms)</th>
<th style="text-align:right">Million messages / sec</th>
</tr>
</thead>
<tbody>
<tr>
<td>BoundedWait</td>
<td>False</td>
<td style="text-align:right">44.86</td>
<td style="text-align:right">0.3109</td>
<td style="text-align:right">0.2756</td>
<td style="text-align:right">22.29</td>
</tr>
<tr>
<td>BoundedWait</td>
<td>True</td>
<td style="text-align:right">44.33</td>
<td style="text-align:right">0.4621</td>
<td style="text-align:right">0.4323</td>
<td style="text-align:right">22.56</td>
</tr>
<tr>
<td>Unbounded</td>
<td>False</td>
<td style="text-align:right">29.80</td>
<td style="text-align:right">0.5915</td>
<td style="text-align:right">0.6329</td>
<td style="text-align:right">33.55</td>
</tr>
<tr>
<td>Unbounded</td>
<td>True</td>
<td style="text-align:right">28.77</td>
<td style="text-align:right">0.4965</td>
<td style="text-align:right">0.4644</td>
<td style="text-align:right">34.76</td>
</tr>
</tbody>
</table>
<h3>Single-Publisher / Multi-Subscriber</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>SyncCont.</th>
<th style="text-align:right">Mean (ms)</th>
<th style="text-align:right">Error (ms)</th>
<th style="text-align:right">StdDev (ms)</th>
<th style="text-align:right">Million messages / sec</th>
</tr>
</thead>
<tbody>
<tr>
<td>BoundedWait</td>
<td>False</td>
<td style="text-align:right">45.43</td>
<td style="text-align:right">0.7245</td>
<td style="text-align:right">0.6777</td>
<td style="text-align:right">22.01</td>
</tr>
<tr>
<td>BoundedWait</td>
<td>True</td>
<td style="text-align:right">45.40</td>
<td style="text-align:right">0.4925</td>
<td style="text-align:right">0.4366</td>
<td style="text-align:right">22.03</td>
</tr>
<tr>
<td>Unbounded</td>
<td>False</td>
<td style="text-align:right">41.81</td>
<td style="text-align:right">0.2038</td>
<td style="text-align:right">0.1907</td>
<td style="text-align:right">23.92</td>
</tr>
<tr>
<td>Unbounded</td>
<td>True</td>
<td style="text-align:right">42.90</td>
<td style="text-align:right">0.2406</td>
<td style="text-align:right">0.2251</td>
<td style="text-align:right">23.31</td>
</tr>
</tbody>
</table>
<h3>Single-Publisher / Single-Subscriber</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>SyncCont.</th>
<th style="text-align:right">Mean (ms)</th>
<th style="text-align:right">Error (ms)</th>
<th style="text-align:right">StdDev (ms)</th>
<th style="text-align:right">Million messages / sec</th>
</tr>
</thead>
<tbody>
<tr>
<td>BoundedWait</td>
<td>False</td>
<td style="text-align:right">45.56</td>
<td style="text-align:right">0.4974</td>
<td style="text-align:right">0.4653</td>
<td style="text-align:right">21.95</td>
</tr>
<tr>
<td>BoundedWait</td>
<td>True</td>
<td style="text-align:right">44.79</td>
<td style="text-align:right">0.3766</td>
<td style="text-align:right">0.3339</td>
<td style="text-align:right">22.33</td>
</tr>
<tr>
<td>Unbounded</td>
<td>False</td>
<td style="text-align:right">28.65</td>
<td style="text-align:right">0.4288</td>
<td style="text-align:right">0.4011</td>
<td style="text-align:right">34.91</td>
</tr>
<tr>
<td>Unbounded</td>
<td>True</td>
<td style="text-align:right">28.53</td>
<td style="text-align:right">0.2122</td>
<td style="text-align:right">0.1985</td>
<td style="text-align:right">35.05</td>
</tr>
</tbody>
</table>

                </article>
            </main>
        </div>
        <footer>
            <p>&#169; Nicolas Portmann</p>
        </footer>
    </body>
</html>