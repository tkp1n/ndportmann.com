{"componentChunkName":"component---src-templates-post-template-js","path":"/load-balancing-perf/","webpackCompilationHash":"d8ceef6725e0a9a86204","result":{"data":{"post":{"id":"225b1914-dceb-5824-b48d-e25d4915a784","html":"<p>Another episode on gaining performance improvements by doing the as little as possible on the hot-path.</p>\n<p><strong><code class=\"language-text\">Tl;dr</code></strong> Do all heavy-lifting upfront or in the background.</p>\n<p>Load balancing is the act of distributing a given load across a set of resources. In this case, we are looking at ways to distribute requests over a set of connections to nodes performing the actual work.</p>\n<p>The design constraints are as follows:</p>\n<ul>\n<li>Requests may arrive concurrently. The load balancer must, therefore, be thread-safe.</li>\n<li>Requests may come in repeating patterns that should be broken up by the load balancer (e.g., by introducing randomness).</li>\n</ul>\n<h2>Synchronized Random</h2>\n<p>The most obvious way to approach this kind of problem is to use <code class=\"language-text\">Random</code> to generate an index into the given array of available connections. As <code class=\"language-text\">Random</code> isn’t thread-safe, we use a <code class=\"language-text\">lock</code> to protect it. Even without contention on the <code class=\"language-text\">lock</code>, this is the slowest possible method clocking in at <strong>26 ns</strong> per load balancing decision.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">Random</span> Random <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Connection</span> <span class=\"token function\">Select</span><span class=\"token punctuation\">(</span>Connection<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> connections<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">lock</span> <span class=\"token punctuation\">(</span>Random<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        index <span class=\"token operator\">=</span> Random<span class=\"token punctuation\">.</span><span class=\"token function\">Next</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> connections<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> connections<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>ThreadStatic Random</h2>\n<p>If the application re-uses the threads (thread-pooling) making the load balancing decisions, we can give each thread it’s own <code class=\"language-text\">ThreadStatic</code> <code class=\"language-text\">Random</code> instance. This way, we don’t have to synchronize access to it. Doing so yields <em>consistently</em> better results at <strong>23 ns</strong> per load balancing decision. Consistently, because this performs independently of possible contention.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token punctuation\">[</span><span class=\"token class-name\">ThreadStatic</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Random</span> Random<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Connection</span> <span class=\"token function\">Select</span><span class=\"token punctuation\">(</span>Connection<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> connections<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> r <span class=\"token operator\">=</span> Random<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        r <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Random <span class=\"token operator\">=</span> r<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">var</span> index <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">Next</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> connections<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> connections<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Pre-Shuffling arrays</h2>\n<p>The next two methods are a bit more niche as they involve pre-randomizing the connection array to avoid the calls to <code class=\"language-text\">Random</code> on the hot path. If only shuffling once isn’t enough, a separate thread could periodically scramble the array in the background. To rearrange the array in-place in linear time, I suggest the use of the so-called <a href=\"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\">“Fisher-Yates shuffle”</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token generic-method\"><span class=\"token function\">Shuffle</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> r <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>Length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> j <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">Next</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">var</span> temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Increment and Modulo</h2>\n<p>We now assume, we have a pre-shuffled list of connections (<code class=\"language-text\">_connections</code>) and an <code class=\"language-text\">_index</code> on the load balancer class. This way, we can implement the actual load balancing decision with a simple <code class=\"language-text\">Interlocked.Increment</code> to add 1 to the <code class=\"language-text\">_index</code> in a thread-safe fashion and a modulo operation to ensure the index lies within the bounds of the <code class=\"language-text\">_connections</code> array. This approach is significantly faster than the previous two, clocking in at <strong>13 ns</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Connection</span> <span class=\"token function\">Select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> index <span class=\"token operator\">=</span> Interlocked<span class=\"token punctuation\">.</span><span class=\"token function\">Increment</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">ref</span> _index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> connections <span class=\"token operator\">=</span> _connections<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> connections<span class=\"token punctuation\">[</span>index <span class=\"token operator\">%</span> connections<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><em>Note:</em> As a simple yet effective optimization, we copy the <code class=\"language-text\">_connections</code> reference to a local variable <code class=\"language-text\">connections</code> which produces slightly better (-1 ns) code.</p>\n<h2>CAS Linked List</h2>\n<p>The runtime cost of the previous approach is mainly due to three things:</p>\n<ol>\n<li>The <code class=\"language-text\">Interlocked</code> operation ensuring thread-safety</li>\n<li>The <code class=\"language-text\">idiv</code> emitted by the module operation ensuring we always read within the bounds of the array</li>\n<li>The bounds-check the runtime does when accessing the array (although the modulo provides safe reads)</li>\n</ol>\n<p>We cannot just drop thread-safety as a design constraint, so we will most likely always use a <code class=\"language-text\">lock</code> or at least an <code class=\"language-text\">Interlocked</code> method. But we may be able to remove the <code class=\"language-text\">idiv</code>. And indeed, we are by using a linked list of all things.</p>\n<h4>Aside</h4>\n<p>Linked lists are generally known for their sub-par performance as a standard list implementation. They fell into discredit because data locality is suboptimal (elements in the list are not necessarily close to each other in memory), and random-access has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> cost. In this specific case, however, we can write better-performing code by using a linked list. <strong>Your mileage may vary</strong>: the larger the list, the bigger the chances that you will see performance loss due to bad data locality. To counter that, you can try to allocate the <code class=\"language-text\">Connection</code> objects and the linked list <code class=\"language-text\">Node</code>s in a tight loop. This way, the runtime will likely place them close to each other in memory. But there is no guarantee.</p>\n<p>On to the implementation: We use a hand-written linked list in which each node comprises a reference to a <code class=\"language-text\">Connection</code> object and a reference to the next item in the list (known as “singly linked list”). Our load balancer class then holds a reference to the current “head” (a <code class=\"language-text\">Node</code>) of the list, which was created from a pre-shuffled array, as shown above. The actual load balancing method is then made up of a single CAS-loop (compare-and-swap), which will store the current node, move the “head” to the next item in the list using <code class=\"language-text\">Interlocked.CompareExchange</code> and return the <code class=\"language-text\">Connection</code> of the previously stored <code class=\"language-text\">Node</code>. If it detects that another thread messed with the list in the meantime, it tries again and again. Another reason why <strong>you may observe different results</strong>: if contention is so high, that a majority of the threads lose the CAS-race, performance will suffer, performance will suffer. In my case, however, the load balancing decision is only a small part of a much larger program with relatively little contention on the LB. When measured with no contention at all, this approach yields a load balancing decision roughly every <strong>10 ns</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Connection</span> <span class=\"token function\">Select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Node</span> selected<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">{</span>\n        selected <span class=\"token operator\">=</span> _node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>\n        Interlocked<span class=\"token punctuation\">.</span><span class=\"token function\">CompareExchange</span><span class=\"token punctuation\">(</span>\n            <span class=\"token keyword\">ref</span> _node<span class=\"token punctuation\">,</span> selected<span class=\"token punctuation\">.</span>Next<span class=\"token punctuation\">,</span> selected\n        <span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> selected\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> selected<span class=\"token punctuation\">.</span>Current<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>The full source is on GitHub at <a href=\"https://github.com/tkp1n/lb\">tkp1n/lb</a></p>\n</blockquote>\n<h2>The numbers</h2>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th align=\"right\">Mean</th>\n<th align=\"right\">Error</th>\n<th align=\"right\">StdDev</th>\n<th align=\"right\">Ratio</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SyncRandom</td>\n<td align=\"right\">26.52 ns</td>\n<td align=\"right\">0.1895 ns</td>\n<td align=\"right\">0.1773 ns</td>\n<td align=\"right\">1.00</td>\n</tr>\n<tr>\n<td>ThreadStaticRandom</td>\n<td align=\"right\">22.61 ns</td>\n<td align=\"right\">0.2784 ns</td>\n<td align=\"right\">0.2605 ns</td>\n<td align=\"right\">0.85</td>\n</tr>\n<tr>\n<td>Modulo</td>\n<td align=\"right\">13.13 ns</td>\n<td align=\"right\">0.0464 ns</td>\n<td align=\"right\">0.0388 ns</td>\n<td align=\"right\">0.50</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td align=\"right\">10.08 ns</td>\n<td align=\"right\">0.0109 ns</td>\n<td align=\"right\">0.0091 ns</td>\n<td align=\"right\">0.38</td>\n</tr>\n</tbody>\n</table>","fields":{"slug":"/load-balancing-perf/","prefix":"2019-10-17"},"frontmatter":{"title":"Randomized Round Robin (Load Balancing) as Fast as Possible","author":"nicolas portmann","category":"dotnet","cover":{"childImageSharp":{"resize":{"src":"/static/e89009f9231e95070d206f381ce597d6/c83a6/taylor-vick-M5tzZtFCOfs-unsplash.jpg"}}}}},"authornote":{"id":"767d534c-f742-5238-9562-ee1dfd6b423d","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/load-balancing-perf/","prev":{"id":"f8a6f120-9471-54d9-8f23-0dac42aec278","fields":{"slug":"/chrome-in-docker/","prefix":"2019-09-30","source":"posts"},"frontmatter":{"title":"Running Chrome in Docker for CI/CD","category":"webdev"}},"next":{"id":"910a0acf-f787-5321-8033-bda3bb04be7e","fields":{"slug":"/io_uring-basics/","prefix":"2020-02-04","source":"posts"},"frontmatter":{"title":"An io_uring based Transport Layer (Part I) - Rationale","category":"iouring"}},"source":"posts"}}}