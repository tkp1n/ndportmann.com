{"componentChunkName":"component---src-templates-post-template-js","path":"/io_uring-basics/","webpackCompilationHash":"d8ceef6725e0a9a86204","result":{"data":{"post":{"id":"910a0acf-f787-5321-8033-bda3bb04be7e","html":"<p>In this series, we are going to explore what it takes to develop an <code class=\"language-text\">io_uring</code>-based Transport layer for .NET. But before we are getting down to the nitty-gritty, we should think about whether this endeavor is a good idea to begin with.</p>\n<p>If you are writing network code for a living or are otherwise familiar with the topic, by all means, skip this episode and come back for the next one, once it‚Äôs ready.</p>\n<h2>What is a Transport Layer?</h2>\n<p>Let‚Äôs start by answering the question of what a Transport layer is. David Fowler and friends (both inside and outside of Microsoft) developed the ASP.NET Connections Abstractions as part of a project codenamed ‚ÄúBedrock‚Äù. If we talk about the Bedrock abstractions here, we talk about the classes and interfaces available as <a href=\"https://github.com/dotnet/aspnetcore/tree/master/src/Servers/Connections.Abstractions/src\">Microsoft.AspNetCore.Connections.Abstractions</a>.</p>\n<p>There are three core concepts to the architecture of Bedrock (<a href=\"https://speakerdeck.com/davidfowl/project-bedrock\">source</a>) upon which most networked .NET applications are built:</p>\n<ul>\n<li>Transports</li>\n<li>Middleware</li>\n<li>Protocols</li>\n</ul>\n<p><strong>Transports</strong> are concerned with how we obtain connections and how bytes are transferred from/to those connections. <strong>Middleware</strong> handles cross-cutting concerns (e.g., sessions, authentication), a concept familiar to ASP.NET developers. <strong>Protocols</strong> handle the details of specific protocols to give the bytes received from a connection a meaning.</p>\n<p>There are already a couple of Transport implementations (also called layers) out there. Most prominently, the <a href=\"https://github.com/dotnet/aspnetcore/tree/master/src/Servers/Kestrel/Transport.Sockets\">Sockets Transport</a> used in Kestrel by default. The Sockets Transport is based on the <code class=\"language-text\">Socket</code> type from the base class library (BCL). It is cleverly written and well optimized.</p>\n<p>The community contributed another, Linux-specific Transport layer.  <a href=\"https://github.com/redhat-developer/kestrel-linux-transport/\">redhat-developer/kestrel-linux-transport</a> is tailored to the best in class Linux APIs for networking (<code class=\"language-text\">epoll</code>, <code class=\"language-text\">AIO</code>, and co.). See Tom Deseyns <a href=\"https://developers.redhat.com/blog/2018/07/24/improv-net-core-kestrel-performance-linux/\">blog post introducing the project</a> for details.</p>\n<h2>Why yet another Transport Layer?</h2>\n<p>So why do we need yet another Transport layer? Well, there is a new kid on the block called <code class=\"language-text\">io_uring</code>. It promises to improve the I/O story for Linux and generally bring better performance to I/O heavy applications. Details on how this is achieved can be found in <a href=\"https://www.slideshare.net/ennael/kernel-recipes-2019-faster-io-through-iouring\">this slideshow</a>.</p>\n<p>With a smart design and some fancy kernel-tricks, <code class=\"language-text\">io_uring</code> offers an API for writing high-performance network code without relying on ‚Äúdirty tricks‚Äù. Userspace network drivers (e.g., DPDK) use stunts such as <em>kernel bypass</em> to achieve high performance at the cost of losing everything the kernel has to offer.</p>\n<p>The current Transport layers were built in a time before the adoption of <code class=\"language-text\">io_uring</code> in an LTS kernel version. <code class=\"language-text\">io_uring</code> is still being developed with new features added in every recent kernel version. What better time than now to investigate the use of <code class=\"language-text\">io_uring</code> in .NET, when we can still contribute to its development via feedback to the kernel devs.</p>\n<p>Writing a new Transport layer doesn‚Äôt only benefit ASP.NET Core. Other frameworks and libraries, such as Orleans, are also jumping onto the Bedrock abstractions. A faster Transport, therefore, means improvements across many applications. And in times where you pay your cloud provider by the CPU cycle, performance matters not only for your users üöÄ but also for your wallet üí∏.</p>\n<p>This series is, therefore, a documentation of the journey towards building yet another Transport layer for .NET networking applications based on the new io_uring API: To outperform the previously mentioned Sockets and Linux Transports on Linux kernels that support it.</p>\n<h2>Why is <code class=\"language-text\">io_uring</code> significant?</h2>\n<h3>The cost of syscalls</h3>\n<p>Ren et al. discovered in their 2019 paper <em><a href=\"https://dl.acm.org/doi/pdf/10.1145/3341301.3359640?download=true\">An Analysis of Performance Evolution of Linux‚Äôs Core Operations</a></em> that the cost of syscalls such as <code class=\"language-text\">mmap</code>, <code class=\"language-text\">read</code>, <code class=\"language-text\">write</code> have gone up significantly in recent times. The 11 root causes responsible for the slowdown fall in one of three categories:</p>\n<ul>\n<li><strong>Security Enhancements</strong> that likely cause permanent slowdowns due to software mitigation for hardware (CPU) issues.</li>\n<li><strong>New Features</strong> that add overhead or just haven‚Äôt been properly optimized yet.</li>\n<li><strong>Configuration Changes</strong>, which were discovered and - for the most part - fixed in recent kernel versions</li>\n</ul>\n<p>Surprisingly, the security enhancements are the least impactful of the above.</p>\n<p>Writing a high-performance network or I/O stack offers many opportunities for optimizations. This is likely the reason why there are so many different network stacks. The go-to site to compare network stacks is <a href=\"https://www.techempower.com/benchmarks\">TechEmpower</a>, where well over 300 frameworks, runtimes, and configurations compete against each other.</p>\n<p>The underlying optimization techniques are, however, the same for most I/O stacks and include but aren‚Äôt limited to the following guidelines:</p>\n<ul>\n<li>Avoid syscalls</li>\n<li>Never block (<code class=\"language-text\">O_NONBLOCK</code>)</li>\n<li>Never copy (<code class=\"language-text\">SO_ZEROCOPY</code>)</li>\n<li>Avoid interrupts (polled I/O)</li>\n<li>Optimize thread affinity</li>\n</ul>\n<h3>Enter <code class=\"language-text\">io_uring</code></h3>\n<p><code class=\"language-text\">io_uring</code> - the brainchild of <a href=\"https://twitter.com/axboe\">Jens Axboe</a> -  is the latest addition to the I/O interfaces of the Linux kernel. It improves the status quo regarding most of the above levers for performance. In theory and extreme cases, it even enables  I/O-operations without any syscalls at all. In more reasonable settings, it allows for a drastically reduced number of syscalls for a given application and to minimize the cost of I/O-operations using neat tricks such as <a href=\"https://patchwork.kernel.org/patch/10792947/\">using pre-mapped I/O buffers</a>.</p>\n<p>If you are used to the BCL, Linux I/O APIs are rarely easy to consume. This is especially true for more sophisticated interfaces such as <code class=\"language-text\">epoll</code>. The same holds for <code class=\"language-text\">io_uring</code>, which is probably why Jens Axboe started writing the <a href=\"https://github.com/axboe/liburing\"><code class=\"language-text\">liburing</code></a> library to make it somewhat easier to profit from <code class=\"language-text\">io_uring</code>.</p>\n<p><code class=\"language-text\">liburing</code> offers convenience methods for each operation supported by <code class=\"language-text\">io_uring</code>. While being convenient, this would mean a lot of P/Invoked methods in the Transport layer should we decide to leverage <code class=\"language-text\">liburing</code>. With the license of <code class=\"language-text\">liburing</code> <a href=\"https://github.com/axboe/liburing/commit/b9f507d50c71b27f5c0239a28fa29db5ce2bf533\">changed to MIT</a>, it was relatively easy to reverse engineer it and to write a similar but managed library: <a href=\"https://github.com/tkp1n/IoUring/#iouring\">IoUring</a>.</p>\n<p>IoUring builds the foundation upon which the IoUring.Transport is built - a foundation which we explore in detail, in the next episode of this series.</p>\n<h2>Summary</h2>\n<p>A new set of I/O interfaces were added to the most recent LTS version of the Linux kernel. There is currently no way to profit from the new APIs from a .NET application. At the same time, the introduction of the Bedrock abstractions made it easier than ever to add a new Transport layer to networked .NET applications. The best time to experiment with an <code class=\"language-text\">io_uring</code> based Transport is now. <a href=\"https://github.com/tkp1n/IoUring\">tkp1n/IoUring</a> is open for contributions!</p>","fields":{"slug":"/io_uring-basics/","prefix":"2020-02-04"},"frontmatter":{"title":"An io_uring based Transport Layer (Part I) - Rationale","author":"nicolas portmann","category":"iouring","cover":{"childImageSharp":{"resize":{"src":"/static/936c91cdf7d05cda92324b4d198f5ee2/c83a6/ethan-robertson-FmMzl1RA7FY-unsplash.jpg"}}}}},"authornote":{"id":"767d534c-f742-5238-9562-ee1dfd6b423d","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/io_uring-basics/","prev":{"id":"225b1914-dceb-5824-b48d-e25d4915a784","fields":{"slug":"/load-balancing-perf/","prefix":"2019-10-17","source":"posts"},"frontmatter":{"title":"Randomized Round Robin (Load Balancing) as Fast as Possible","category":"dotnet"}},"source":"posts"}}}