{"componentChunkName":"component---src-templates-post-template-js","path":"/chrome-in-docker/","webpackCompilationHash":"786d471545d98ebf3726","result":{"data":{"post":{"id":"ef848ccc-bf38-52c7-9adb-088df962481a","html":"<p>Running Chrome headless in Docker turns out to be surprisingly hard. Many resources on the internet suggest to disable the sandbox, and everything works fine. <strong>Please don’t trust random people on the internet, telling you to disable security features</strong>.</p>\n<p>Ask yourself the following: Do you really trust all the, let’s say <strong>18847 packages</strong> that are included with a barebones <code class=\"language-text\">ng new</code> Angular application to run outside a sandbox? I sure don’t.</p>\n<p><strong><code class=\"language-text\">Tl;dr</code></strong> Checkout the <a href=\"https://github.com/tkp1n/chromium-ci/blob/master/README.md\">README</a> of <code class=\"language-text\">tkp1n/chromium</code> to get started.</p>\n<p>As you’ve decided to skip the short version, let’s start with why you want to run Chrome in Docker in the first place.</p>\n<h2>Rationale</h2>\n<p>Testing web applications is typically done within a browser. I use Chrome to test the Angular app I’m working on at the moment. Naturally, I want to execute those tests as part of the CI/CD pipeline of the project as well. That’s is where things get tricky. The easiest would be to install Chrome on the build server. That is what you get if you make use of <a href=\"https://github.com/features/actions\">GitHub Actions</a> or any other decent public CI/CD service.</p>\n<p>Unfortunately, not everything is developed in the open and convincing corporate IT to install Chrome on all their build servers may not be manageable. One could even argue that it isn’t desirable in the first place. Consider this: I might want to test my project using a different version of Chrome than some other team. Docker makes a compelling argument both to avoid lengthy discussions with corporate IT and to get reproducible builds using the exact versions of the tools I prefer.</p>\n<p>Two years ago, I would have likely used <a href=\"https://phantomjs.org/\">PhantomJS</a> to run automated front-end tests on a server. However, as the project is discontinued, we have to look at alternatives. The more or less drop-in replacement would be <a href=\"https://github.com/GoogleChrome/puppeteer\">Puppeteer</a> by Google. Unfortunately, Puppeteer isn’t exactly plug-and-play as several dependencies to run Chrome may be missing on the target system and they do not get installed with Puppeteer. As it turns out, Puppeteer isn’t even needed to test an Angular app on a build server. All you need is a working installation of Chromium and some command-line options.  </p>\n<h2>The Docker image</h2>\n<p>I assembled a <a href=\"https://github.com/tkp1n/chromium-ci/blob/master/Dockerfile\">Dockerfile</a> on the foundation of <a href=\"https://www.alpinelinux.org/\">Alpine Linux</a>, one of the smallest base images available. It uses the edge channel, as Chromium > 76 is required for things to run smoothly and it isn’t yet in one of the stable versions. Luckily it is a matter of time until we can use the standard Alpine base image. The only things installed are Chromium (as well as it’s recommended dependencies), Node.js and npm (to execute the tests) as well as dumb-init (explained later). A user <code class=\"language-text\">chromium</code> is created and switched to, ensuring we don’t execute Chrome as a privileged user. <code class=\"language-text\">CHROME_BIN</code> is set to avoid the need for additional configuration in the applications under test (e.g., karma.conf.js), and dumb-init is bootstrapped to avoid zombie processes of Chrome sticking around as proposed by this <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#tips\">troubleshooting section of Puppeteer</a>.</p>\n<p>You may think this sounds way too straight-forward to justify a blog post and you’d be right. Sadly, things aren’t as easy as they seem. Starting Chrome in the Docker image built by above Dockerfile fails spectacularly with an error similar to this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Cannot start ChromeHeadless\nFailed to move to new namespace: PID namespaces supported, Network namespace supported, but failed: errno <span class=\"token operator\">=</span> Operation not permitted\n<span class=\"token punctuation\">[</span>0929/190238.494297:FATAL:zygote_host_impl_linux.cc<span class=\"token punctuation\">(</span><span class=\"token number\">187</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> Check failed: ReceiveFixedMessage<span class=\"token punctuation\">(</span>fds<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>, kZygoteBootMessage, sizeof<span class=\"token punctuation\">(</span>kZygoteBootMessage<span class=\"token punctuation\">)</span>, <span class=\"token operator\">&amp;</span>boot_pid<span class=\"token punctuation\">)</span>.\nReceived signal <span class=\"token number\">6</span>\n  r8: 00007ffebb72b300  r9: 00007f93224c114c r10: 0000000000000008 r11: 0000000000000246\n r12: 00007ffebb72b690 r13: 0000000000000000 r14: 00007ffebb72b440 r15: 00000000000000a0\n  di: 0000000000000002  si: 00007ffebb72adc0  bp: 00007ffebb72adc0  bx: 0000000000000006\n  dx: 0000000000000000  ax: 0000000000000000  cx: 00007f9322474225  sp: 00007ffebb72ada8\n  ip: 00007f9322474225 efl: 0000000000000246 cgf: 002b000000000033 erf: 0000000000000000\n trp: 0000000000000000 msk: 0000000000000000 cr2: 0000000000000000\n<span class=\"token punctuation\">[</span>end of stack trace<span class=\"token punctuation\">]</span>\nCalling _exit<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>. Core <span class=\"token function\">file</span> will not be generated.</code></pre></div>\n<p>Why is that? Because Chrome uses certain syscalls that usually aren’t allowed from within a Docker container: <code class=\"language-text\">arch_prctl</code> <code class=\"language-text\">chroot</code> <code class=\"language-text\">clone</code> <code class=\"language-text\">fanotify_init</code> <code class=\"language-text\">name_to_handle_at</code> <code class=\"language-text\">open_by_handle_at</code> <code class=\"language-text\">setdomainname</code> <code class=\"language-text\">sethostname</code> <code class=\"language-text\">syslog</code> <code class=\"language-text\">unshare</code> <code class=\"language-text\">vhangup</code> <code class=\"language-text\">setns</code> <a href=\"https://github.com/docker/for-linux/issues/496#issuecomment-441149510\">(source)</a>.</p>\n<h2>Convincing Chrome to actually start</h2>\n<p>We have 4 different options to get things working again:</p>\n<ol>\n<li><strong>We disable the sandbox.</strong> This method defeats the entire purpose of this exercise. <em>Don’t do that.</em></li>\n<li><strong>We start the Docker container with</strong> <code class=\"language-text\">--privileged</code><strong>.</strong> This way, our tests are sandboxed, but the security policies enforced by Docker are entirely disabled. <em>Don’t do that either.</em></li>\n<li><strong>We start the Docker container with</strong> <code class=\"language-text\">--cap-add=SYS_ADMIN</code><strong>.</strong> This approach is better than the above but still not perfect. It enables CAP<em>SYS</em>ADMIN capabilities, which usually are not granted. See <a href=\"http://man7.org/linux/man-pages/man7/capabilities.7.html\">capabilities(7)</a> for more detail. The <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md\">Puppeteer troubleshooting guide</a> suggests this option as well. <em>Do this only, if below option does not work for you.</em></li>\n<li><strong>We provide a custom seccomp</strong>. Starting the container with <code class=\"language-text\">--security-opt seccomp=chrome.json</code> allows us to provide a JSON file with an exact whitelist of syscalls required by Chrome. We can run the browser sandbox and still prevent anything inside the container to go rouge - <em>My personal favorite.</em></li>\n</ol>\n<p>The <code class=\"language-text\">chrome.json</code> I am referring to in option 4 can be found <a href=\"https://github.com/tkp1n/chromium-ci/blob/master/seccomp/chromium.json\">here</a>. It is based on the <a href=\"https://raw.githubusercontent.com/moby/moby/master/profiles/seccomp/default.json\">default seccomp profile from the moby repository</a> and the whitelist contained in the profile is extended with the syscalls mentioned above.</p>\n<p>The Docker documentation gives a good starting point for additional information on the <a href=\"https://docs.docker.com/engine/security/seccomp/\">seccomp security profiles</a>. There is even a 20-minute <a href=\"https://github.com/docker/labs/tree/master/security/seccomp\">lab</a> in which you can learn how to figure out what syscalls are missing from the default seccomp profile.</p>\n<h2>What we’ve achieved</h2>\n<p>With the Docker image <code class=\"language-text\">tkp1n/chromium</code> and some tweaking - preferably by setting the extended seccomp profile as shown in the sample below - we can test an angular app on any CI/CD server that runs Docker. Without installing anything or setting Chrome into a dangerous mode.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run\n    --security-opt <span class=\"token assign-left variable\">seccomp</span><span class=\"token operator\">=</span>seccomp/chromium.json\n    -v <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">`</span></span>/node-ci-demo:/app\n    tkp1n/chromium\n    <span class=\"token function\">npm</span> run <span class=\"token builtin class-name\">test</span> -- --no-watch --browsers<span class=\"token operator\">=</span>ChromeHeadless</code></pre></div>\n<p>Also make sure to checkout the <a href=\"https://github.com/tkp1n/chromium-ci/blob/master/README.md\">README</a> of <code class=\"language-text\">tkp1n/chromium</code> to get started.</p>","fields":{"slug":"/chrome-in-docker/","prefix":"2019-09-30"},"frontmatter":{"title":"Running Chrome in Docker for CI/CD","author":"nicolas portmann","category":"webdev","cover":{"childImageSharp":{"resize":{"src":"/static/84cd14ec68603a8fcc8cd6b0eb8d71fb/c83a6/chuttersnap-9cCeS9Sg6nU-unsplash.jpg"}}}}},"authornote":{"id":"2bd2c695-fbab-5aba-9e5f-558db048c85d","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/chrome-in-docker/","prev":{"id":"b5d1c423-56c6-5287-a273-808e793a15ba","fields":{"slug":"/breaking-records-with-core-3-0/","prefix":"2019-07-26","source":"posts"},"frontmatter":{"title":"Breaking all existing Hex Encoding Records with .NET Core 3.0","category":"dotnet"}},"next":{"id":"e71bf5d0-5b23-5e2d-b4c3-b5a68765caf3","fields":{"slug":"/load-balancing-perf/","prefix":"2019-10-17","source":"posts"},"frontmatter":{"title":"Randomized Round Robin (Load Balancing) as Fast as Possible","category":"dotnet"}},"source":"posts"}}}