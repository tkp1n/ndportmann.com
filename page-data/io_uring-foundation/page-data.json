{"componentChunkName":"component---src-templates-post-template-js","path":"/io_uring-foundation/","result":{"data":{"post":{"id":"e6d9a38a-8587-5748-92e6-3845264e26b5","html":"<p>In this series, we are going to explore what it takes to develop an <code class=\"language-text\">io_uring</code>-based Transport layer for .NET. In this episode, we introduce the <code class=\"language-text\">IoUring</code>-library - the foundation on which we shall build our Transport layer.</p>\n<p>Make sure to check out the <a href=\"https://ndportmann.com/io_uring-rationale/\">previous episode</a> in this series, where we talked about what a .NET Transport layer is, and why we should build a new one.\nIf you are already familiar with the basics of Linux network programming and <code class=\"language-text\">IoUring</code>s native counterpart <code class=\"language-text\">liburing</code>, by all means, skip this episode and come back for the next one, once it’s ready.</p>\n<h2>Linux Network Programming Fundamentals</h2>\n<p>This chapter is a <strong>very</strong> high-level overview and over-simplification of the syscalls traditionally involved in writing TCP client/server code. I highly recommend the books by Richard Stevens (e.g., <a href=\"https://www.amazon.com/dp/0131411551/ref=cm_sw_em_r_mt_dp_U_kNepEbW5QN4R0\">UNIX Network Programming</a>), if you want to dig deeper.</p>\n<p>It typically all starts with a call to <code class=\"language-text\">socket</code>. We specify the family, type, and protocol of the I/O we want to perform and receive a socket file descriptor in return. Remember, everything in Linux is a file.</p>\n<h3>Server-Side</h3>\n<p>A TCP server continues by calling <code class=\"language-text\">bind</code>, to assign the socket to an address (port) on the server. Once bound to a port, the server can start to <code class=\"language-text\">listen</code> with the next syscall. When calling <code class=\"language-text\">listen</code>, the server specifies the number of pending incoming connections it wants to queue up. A call to <code class=\"language-text\">accept</code> returns an actual client connection, once a client tries to connect to the server. The file descriptor returned by <code class=\"language-text\">accept</code> is later used to exchange data with the client.</p>\n<h3>Client-Side</h3>\n<p>On the client-side, things are uncomplicated. Once we have a socket, obtained through the equally named syscall, we can <code class=\"language-text\">connect</code> directly to a server by specifying its address.</p>\n<h3>Exchanging Data</h3>\n<p>Syscalls like <code class=\"language-text\">read</code> (and co.) receive data, while their <code class=\"language-text\">write</code> counterparts send data across the socket. It all ends, once one party calls <code class=\"language-text\">close</code> to terminate the connection.</p>\n<h2>Non-blocking Sockets and Polling</h2>\n<p>Without modification, the above syscalls are all blocking the calling thread. Blocking means that the invoked functions only return once the requested operation completed. For example, <code class=\"language-text\">accept</code> only returns once a client connects to the server. While these syscalls are doing their thing, the thread calling it is blocked and cannot do anything else. It turns out this is rather inefficient, as threads are still a valuable resource that we should use as efficiently as possible.</p>\n<p>Non-blocking options were added to the syscalls mentioned above to mitigate this inefficiency. With those options enabled, the syscalls return immediately. Even if the requested operation is still in progress, we can, therefore, start multiple socket operations using the same thread and use a polling and waiting mechanism to check and wait for the requested operations to complete. The best way to perform this polling and waiting <em>was</em> the <code class=\"language-text\">epoll</code> interface. <em>Was</em> because, with <code class=\"language-text\">io_uring</code>, we now have an even better option at hand.</p>\n<p>Describing the <code class=\"language-text\">epoll</code> interface in detail is too much for the scope of this episode. Since we aren’t using it in our endeavor, this shouldn’t matter too much.</p>\n<h2>Reducing the Number of Syscalls</h2>\n<p>In <a href=\"https://ndportmann.com/io_uring-rationale/\">the last episode</a>, we established some levers we can pull to optimize the performance of networking code. One of those is the reduction of syscalls. The rationale behind this is the cost associated with invoking syscalls. Again, check out the <a href=\"https://ndportmann.com/io_uring-rationale/\">previous episode</a> for more details on this.</p>\n<p>The community introduced <code class=\"language-text\">libaio</code> (AIO) to tackle this problem. The new syscalls behind AIO can be used to submit multiple socket operations at once (<code class=\"language-text\">io_submit</code>) and to get the results for completed operations with another syscall <code class=\"language-text\">io_getevents</code>. Unfortunately, AIO didn’t solve all our problems. <code class=\"language-text\">io_submit</code> can (sometimes) block, and performance overall isn’t great. See this <a href=\"https://www.youtube.com/watch?v=-5T4Cjw46ys\">presentation from Jens Axboe</a> for more hints in this direction.</p>\n<h2>Enter <code class=\"language-text\">io_uring</code></h2>\n<blockquote>\n<p>DISCLAIMER: This post covers parts of the <code class=\"language-text\">io_uring</code> API surface that shipped with kernel version 5.4. It grew a lot since then, but by the time of writing, 5.4 is LTS.</p>\n</blockquote>\n<p>Jens Axboe introduced <code class=\"language-text\">io_uring</code> to solve a multitude of issues around non-blocking, fast, and parallel I/O with few syscalls. “One API to rule them all” so to say. <code class=\"language-text\">io_uring</code> consists of two ring buffers (hence the name): a submission queue and a completion queue. The application writes I/O operations to the submission queue, which the kernel consumes and executes. The kernel, on the other hand, writes the results of the completed I/O operations to the completion queue, which the application consumes and inspects. There is no “syscall-tax” per submission or completion because the memory behind the two queues is shared between the kernel and the application. Setting up an <code class=\"language-text\">io_uring</code>-instance is, therefore, relatively involved.</p>\n<h3>Setup</h3>\n<p>The syscall <code class=\"language-text\">io_uring_setup</code> allows us to specify the desired size of the submission queue. The kernel adjusts this number to the next power of two, given it isn’t already chosen as such. The kernel, in turn, defines the size of the completion queue to be twice as large as the submission queue by default, although the user can overwrite this.</p>\n<h4>Completion Queue Size and Overflows</h4>\n<p>The completion queue should be larger than the submission queue to ensure there is enough space for queued up operations to complete “at the same time”. Newer kernel versions (> 5.5.) have an internal buffer to avoid completion queue overflows. On platforms where this feature is lacking, the application has to take care that no more I/O operations are in flight than fit the completion queue.</p>\n<h4>I/O Polling</h4>\n<p>I/O in the Linux kernel usually is interrupt-driven. In interrupt mode, the I/O device notifies the kernel via a so-called interrupt about the completion of I/O operations. With <code class=\"language-text\">io_uring</code>, we have the option to enable I/O polling (a privileged operation). Interrupt driven I/O is more efficient for most workloads, as it prevents the kernel from wasting CPU cycles by polling for I/O operations that are still pending.</p>\n<h4>Submission Queue Polling</h4>\n<p>Typically, the user application must notify the kernel about I/O operations added to the submission queue. <code class=\"language-text\">io_uring</code> offers the privileged option to enable submission queue polling. In this mode, the kernel polls the submission Queue until a configurable time-out. Should the time-out occur, the kernel falls back to the normal mode where the application must notify the kernel about submissions.</p>\n<h4>The C# API - Constructor</h4>\n<p>Behind the scenes, the setup of an <code class=\"language-text\">io_uring</code> instance is relatively complicated. It includes not only the call to <code class=\"language-text\">io_uring_setup</code> but also multiple <code class=\"language-text\">mmap</code>s to get access to the shared memory behind the two ring buffers. All of this complexity is handled for you by the constructor of the <code class=\"language-text\">Ring</code> class introduced in <a href=\"https://github.com/tkp1n/IoUring\"><code class=\"language-text\">IoUring</code></a>. Given the explanation of the various options above, the following two samples are hopefully fairly self-explanatory.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> ioUringDefault <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Ring</span><span class=\"token punctuation\">(</span><span class=\"token number\">4096</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> ioUringCrazy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Ring</span><span class=\"token punctuation\">(</span><span class=\"token number\">4096</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">RingOptions</span>\n<span class=\"token punctuation\">{</span>\n    CompletionQueueSize <span class=\"token operator\">=</span> <span class=\"token number\">4096</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span>\n    EnablePolledIo <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    EnableSubmissionPolling <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    PollingThreadIdleAfter <span class=\"token operator\">=</span> TimeSpan<span class=\"token punctuation\">.</span><span class=\"token function\">FromSeconds</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    SubmissionQueuePollingCpuAffinity <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>All settings can be queried as public properties on the <code class=\"language-text\">Ring</code> instance. The most interesting one is the size of the completion queue, as it is set by the kernel.</p>\n<h4>A Word of Warning: ENOMEM</h4>\n<p>On most Linux distributions, the limit on the locked bytes of memory is set relatively low. This leads to errors (<code class=\"language-text\">ENOMEM</code>), even when creating small rings. To adjust this limit, increase the configuration of the value <code class=\"language-text\">RLIMIT_MEMLOCK</code>. How this is done exactly depends on your distribution. Please refer to the <a href=\"https://github.com/tkp1n/IoUring#setting-proper-resource-limits-rlimit_memlock\">README</a> of <code class=\"language-text\">IoUring</code> for a starting point on how this is achieved.</p>\n<h3>Prepare I/O Operations</h3>\n<p>Before I/O operations can be submitted to the kernel for execution, they need to be prepared. Preparing an I/O operation is relatively cheap and done by copying some pointers and flags. It neither includes a syscall, nor a memory-barrier. The number of I/O operations that can be prepared without submitting them is limited by the size of the ring (or, more specifically, the submission queue size) set during its construction.</p>\n<p>It is generally desirable to prepare as many I/O operations as possible before submitting them. Submitting the prepared operations includes at least a memory-barrier when in polling mode and additionally a syscall in “normal mode”.</p>\n<p>To get an overview over the I/O operations supported by <code class=\"language-text\">io_uring</code>, please refer to the LWN article <a href=\"https://lwn.net/Articles/810414/\">“The rapid growth of io_uring”</a>. I couldn’t do much more than copying Jonathan’s statements there.</p>\n<h4>User data</h4>\n<p>Each I/O operation carries 64-bits of user data. This user data is read by the kernel and routed through to the completion queue entry. This allows the application to establish a context between a submission and a completion.</p>\n<h4>Submit Options</h4>\n<p>Various options can be set with each I/O operation to control how it is executed:</p>\n<ul>\n<li><code class=\"language-text\">IOSQE_IO_DRAIN</code> - execute this operation once all other pending operations are completed.</li>\n<li><code class=\"language-text\">IOSQE_IO_LINK</code> - execute this and all following operations with this flag set in the order they were submitted.</li>\n<li>… additional options were introduced after kernel version 5.4 - not discussed here.</li>\n</ul>\n<h4>The C# API - PrepareXXX</h4>\n<p>Let’s have a look at how some of the supported I/O operations can be prepared using the C# API:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> r <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Ring</span><span class=\"token punctuation\">(</span><span class=\"token number\">4096</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Prepare a no-op with the drain option set</span>\nr<span class=\"token punctuation\">.</span><span class=\"token function\">PrepareNop</span><span class=\"token punctuation\">(</span><span class=\"token named-parameter punctuation\">userData</span><span class=\"token punctuation\">:</span> <span class=\"token number\">42UL</span><span class=\"token punctuation\">,</span> <span class=\"token named-parameter punctuation\">options</span><span class=\"token punctuation\">:</span> SubmissionOption<span class=\"token punctuation\">.</span>Drain<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Prepare a 'readv' on the file descriptor fd using nrOfIovecs iovecs</span>\nr<span class=\"token punctuation\">.</span><span class=\"token function\">PrepareReadV</span><span class=\"token punctuation\">(</span>fileDescriptor<span class=\"token punctuation\">,</span> iovecs<span class=\"token punctuation\">,</span> nrOfIovecs<span class=\"token punctuation\">,</span> <span class=\"token named-parameter punctuation\">userData</span><span class=\"token punctuation\">:</span> <span class=\"token number\">43UL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Add a one-shot poll for POLLIN on the given socket file descriptor</span>\nr<span class=\"token punctuation\">.</span><span class=\"token function\">PreparePollAdd</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">ushort</span><span class=\"token punctuation\">)</span> POLLIN<span class=\"token punctuation\">,</span> <span class=\"token named-parameter punctuation\">userData</span><span class=\"token punctuation\">:</span> <span class=\"token number\">44UL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Submit and Reap Completions</h3>\n<p>We learned how to create a <code class=\"language-text\">Ring</code> and prepare I/O operations. All we need now is a way to make the kernel aware of the prepared submissions and to check for, or wait for completions.</p>\n<h4>The C# API - Submit &#x26; Flush</h4>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token comment\">// Submit all prepared operations</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> nofSubmittedOps <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">Submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Flush all submitted operations and block until 1 completed</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> nofFlushedOps <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">Flush</span><span class=\"token punctuation\">(</span>nofSubmittedOps<span class=\"token punctuation\">,</span> <span class=\"token named-parameter punctuation\">minComplete</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>That’s it.</p>\n<p>The <code class=\"language-text\">Submit</code> helper method introduces a memory-barrier so that the kernel has a chance to see what we’ve prepared for it. If the kernel is in polling mode, a call to submit is enough, given the polling time-out hasn’t triggered yet. <code class=\"language-text\">Flush</code> is an intelligent wrapper around the syscall <code class=\"language-text\">io_uring_enter</code> that is responsible for both making the kernel aware of the submitted items but also to reap the completions that happened since the last call. It is intelligent, because if the kernel is in the polling mode, the syscall is only made if the kernel currently isn’t “sleeping” after a time-out. If polling is not enabled, <code class=\"language-text\">Flush</code> always calls <code class=\"language-text\">io_uring_enter</code>. The second, optional parameter is the number of completions to await. If this parameter is set to <code class=\"language-text\">0</code>, the call does not block.</p>\n<p>Note that even with <code class=\"language-text\">minComplete</code> set to <code class=\"language-text\">0</code> <code class=\"language-text\">Flush</code> could take a while, as most submitted operations are started during the invocation and, if possible without blocking, completed synchronously.</p>\n<p>This is the most exciting feature of <code class=\"language-text\">io_uring</code>. One syscall to:</p>\n<ul>\n<li>Submit multiple I/O operations</li>\n<li>Complete all operations that can be completed synchronously without blocking</li>\n<li>Get the result of all operations that completed since the last call</li>\n</ul>\n<h3>Inspect Completions</h3>\n<p>Completions are straightforward. A struct, two members. The user data provided when preparing the operation that completed and its result. If the result is negative, it is the “negative errno” that lead to the error. Non-negative results can be considered a successful completion of the I/O operation.</p>\n<h4>The C# API - Completions</h4>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\">Completion</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">.</span><span class=\"token function\">TryRead</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">ref</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>result <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">ErrnoException</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>c<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Console<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span><span class=\"token interpolation-string\"><span class=\"token string\">$\"I/O operation </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span><span class=\"token expression language-csharp\">c<span class=\"token punctuation\">.</span>userData</span><span class=\"token punctuation\">}</span></span><span class=\"token string\"> completed\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token interpolation-string\"><span class=\"token string\">$\"successfully with result: </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span><span class=\"token expression language-csharp\">c<span class=\"token punctuation\">.</span>result</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Summary</h2>\n<p>The Linux network and I/O APIs have evolved drastically over the years. What started with some simple syscalls quickly became a hard to navigate landscape of async options and functions. <code class=\"language-text\">io_uring</code> promises to simplify things again for network developers. Just a couple of syscalls, easily wrapped and hidden behind a library like <code class=\"language-text\">liburing</code> or <code class=\"language-text\">IoUring</code> enable us to quickly write high-performance networking code.</p>\n<p>Stay tuned for more episodes on this topic and check out the <a href=\"https://github.com/tkp1n/IoUring\"><code class=\"language-text\">IoUring</code></a> repository, where we build next network Transport layer for .NET. If you want to get involved, there are a couple of open issues waiting for eager contributors 😉.</p>","fields":{"slug":"/io_uring-foundation/","prefix":"2020-02-07"},"frontmatter":{"title":"An io_uring based Transport Layer (Part II) - Foundation","author":"nicolas portmann","category":"iouring","cover":{"childImageSharp":{"resize":{"src":"/static/5e76d08a4e5bd2d15dcda87142c4b17e/9dc27/mirko-blicke-V_y81v_lI4k-unsplash.jpg"}}}}},"authornote":{"id":"d6a2ffb2-8fcc-537a-80e6-b75d0a167975","html":"<p><strong>Nicolas Portmann</strong> Software developer working on the back-end of the swiss cashless payment platform. Writing code for hardware security modules (Embedded C) and bridging the gap between low level network protocols and high level business applications (in Java/C#).</p>"}},"pageContext":{"slug":"/io_uring-foundation/","prev":{"id":"bda1a9b7-0044-58e4-90a0-f77b4a5c58e5","fields":{"slug":"/io_uring-rationale/","prefix":"2020-02-04","source":"posts"},"frontmatter":{"title":"An io_uring based Transport Layer (Part I) - Rationale","category":"iouring"}},"next":{"id":"33be0287-b0b9-5efb-b696-670cac95869e","fields":{"slug":"/io_uring-preview-release/","prefix":"2020-06-08","source":"posts"},"frontmatter":{"title":"An io_uring based Transport Layer (Part III) - Preview Release","category":"iouring"}},"source":"posts"}}}