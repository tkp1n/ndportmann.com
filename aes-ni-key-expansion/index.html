<!DOCTYPE html><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>AES-NI (.NET) - Key Expansion</title>
        <meta name="description" content="A Software Engineering Blog">
        <meta property="og:url" content="https://ndportmann.com/aes-ni-key-expansion/">
        <meta property="og:title" content="AES-NI (.NET) - Key Expansion">
        <meta property="og:description" content="A blog about software engineering and applied cryptography.">
        <meta property="og:type" content="article">
        <meta name="twitter:site" content="@tkp1n">
        <meta name="twitter:creator" content="@tkp1n">
        <meta name="twitter:card" content="summary">
        <style>
            
            /*! tailwindcss v2.1.1 | MIT License | https://tailwindcss.com *//*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */*,::after,::before{box-sizing:border-box}:root{-moz-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Consolas,'Liberation Mono',Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}button{background-color:transparent;background-image:none}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}body{font-family:inherit;line-height:inherit}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}:root{--size-0_5:0.125rem;--size-1:0.250rem;--size-1_5:0.375rem;--size-2:0.5rem;--size-3:0.75rem;--size-3_5:0.875rem;--size-4:1rem;--size-4_5:1.125rem;--size-5:1.25rem;--size-6:1.5rem;--size-7:1.75rem;--size-7_5:1.875rem;--size-8:2rem;--size-9:2.25rem;--size-10:2.5rem;--size-xs:20rem;--size-md:28rem;--weight-extralight:200;--weight-light:300;--weight-bitbold:400;--weight-semibold:600;--blue-500:rgba(59, 130, 246, 1);--blue-600:rgba(37, 99, 235, 1);--blue-800:rgba(37, 99, 235, 1);--white:rgba(255, 255, 255, 1);--gray-200:rgba(229, 231, 235, 1);--gray-500:rgba(107, 114, 128, 1);--gray-800:rgba(31, 41, 55, 1);--black:rgba(0, 0, 0, 1)}*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.max-w-screen-lg{max-width:1024px}.max-w-screen-md{max-width:768px}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.mx-auto{margin-left:auto;margin-right:auto}.shadow{--tw-shadow:0 1px 3px 0 rgba(0, 0, 0, 0.1),0 1px 2px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.rounded{border-radius:.25rem}h2{font-size:var(--size-5);line-height:var(--size-7);margin-left:var(--size-4);margin-top:var(--size-6)}@media (min-width:1024px){h2{font-size:var(--size-6);line-height:var(--size-8)}}h3{font-size:var(--size-4_5);line-height:var(--size-7);margin-top:var(--size-6);color:var(--gray-800);font-weight:var(--weight-semibold);letter-spacing:-.025em}@media (min-width:1024px){h3{font-size:var(--size-5);line-height:var(--size-7)}}h4{margin-top:var(--size-5);font-weight:var(--weight-semibold)}.icon{width:var(--size-5);height:var(--size-5);margin-bottom:var(--size-1);display:inline}.tag{padding-right:var(--size-3);white-space:nowrap}pre{border-radius:var(--size-1)}ul{list-style:disc;padding-left:var(--size-4_5)}ol{list-style:decimal;padding-left:var(--size-4_5)}blockquote{margin-top:1rem;padding-left:1rem;border-left:4px solid #dadada}th{text-align:start;font-weight:var(--weight-bitbold)}code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:0 0;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#8292a2}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.header h1{margin-top:0;font-size:var(--size-4_5);line-height:var(--size-7)}@media(min-width:1024px){.header h1{font-size:var(--size-5)}}.sub{font-size:var(--size-4);line-height:var(--size-6);font-weight:var(--weight-extralight);height:var(--size-6)}.sub span{animation:fade 10s linear infinite 0s;opacity:0;overflow:hidden;position:absolute}.sub span:nth-child(2){animation-delay:2.5s}.sub span:nth-child(3){animation-delay:5s}.sub span:nth-child(4){animation-delay:7.5s}@media(min-width:1024px){.sub{font-size:var(--size-4_5);line-height:var(--size-7)}}@keyframes fade{0%{opacity:0}5%{opacity:0}10%{opacity:1}25%{opacity:1}30%{opacity:0}100%{opacity:0}}.outer{margin-top:var(--size-8);background-color:var(--blue-600);transform:skewY(6deg);width:66.666667%;max-width:var(--size-xs);min-width:-webkit-min-content;min-width:min-content}@media(min-width:1024px){.outer{max-width:var(--size-md)}}.inner{padding:var(--size-2);background-color:var(--white);transform:skewY(-6deg);width:80%}header>h1{font-size:var(--size-6);line-height:var(--size-8);margin-top:var(--size-7)}@media(min-width:1024px){header>h1{font-size:var(--size-7);line-height:var(--size-9)}}h1,h2,h3,h4,h5,h6{margin-left:0}.content{max-width:768px;margin-top:var(--size-6);padding-right:var(--size-5);padding-left:var(--size-5)}.text{margin-top:var(--size-2);font-size:var(--size-4)}.text p{padding-top:var(--size-4)}.text a{color:var(--blue-600)}.text a:hover{text-decoration:underline}.text pre{margin-top:var(--size-1);margin-bottom:var(--size-1)}.text table{table-layout:auto;width:100%;margin-top:var(--size-2);margin-bottom:var(--size-2)}.text tr{border-bottom-width:1px}.text td{padding:var(--size-1_5)}:not(a)>code{border-radius:var(--size-1);padding:var(--size-0_5);background-color:var(--gray-200)}.text blockquote>p{padding-top:0}footer{padding-top:var(--size-4);padding-bottom:var(--size-2);width:100%;text-align:center}
        </style>
        <link rel="stylesheet" href="../prism-okaidia.min.css">
        <link rel="stylesheet" href="../katex.min.css">
    </head>
    <body>
        <a href="/" class="header">
            <div class="outer shadow rounded mx-auto">
                <div class="inner shadow rounded mx-auto">
                    <header>
                        <h1>Nicolas Portmann</h1>
                        <div class="sub">
                            <span>Software Engineering</span>
                            <span>Security Engineering</span>
                            <span>Applied Cryptography</span>
                            <span>Performance Optimization</span>
                        </div>
                    </header>
                </div>
            </div>
        </a>
        <div class="content container mx-auto">
            <main>
                <header>
                    <h1>AES-NI (.NET) - Key Expansion</h1>
                    
                    
    <section>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            <span class="meta">2019/03/18</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
            </svg>
            <span class="meta">Nicolas Portmann</span>
        </span>
        <span class="tag">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="icon">
                <path 
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0
                        014-4z"></path>
            </svg>
            <span class="meta">Crypto</span>
        </span>
    </section>

                </header>
                <article class="text">
                    <blockquote>
<p>This is the second post of a small series on AES-NI and .NET Core hardware intrinsics. Please also have a look at the <a href="https://ndportmann.com/improving-dotnet-crypto-code/" title="Improving .NET Crypto Code - ndportmann.com">first post</a> and be patient for the next one, to which I'll add the link once it is are ready.</p>
</blockquote>
<p>We concluded the last post in this series with the realization, that the .NET frameworks AES implementation isn't optimized for encrypting small payloads with quickly changing keys. Creating the <code>ICryptoTransform</code> for the ever-changing AES keys in the brute-force code we analyzed in the last post was responsible for about 60% of the total runtime of the &quot;attack&quot;.</p>
<p>This post will, therefore, focus on how we can reduce this overhead by implementing only the absolute minimum required to work with a new AES key; the key expansion. The AES key expansion is required to expand the 128-, 192- or 256-bits of keying material to a key schedule of 10, 12 or 14 round keys (128-bits each). The exact nature of this process is described in detail in <a href="https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf" title="NIST FIPS 197">NIST FIPS 197</a> which standardized Rijndael as AES in 2001. As this series is about .NET hardware intrinsics, we also refer to the <a href="https://www.intel.com/content/dam/doc/white-paper/advanced-encryption-standard-new-instructions-set-paper.pdf" title="AES-NI white paper - Intel">Intel white-paper</a> which introduced the use of Intel's AES new instructions in 2008.</p>
<h2>History lesson (skip if you are not interested)</h2>
<p>In 2008, most AES implementations were written entirely in software. There were some <a href="https://iacr.org/archive/ches2005/031.pdf" title="Paper about AES on FPGA ">FPGAs</a> and even <a href="https://www.heliontech.com/aes.htm" title="AES cores from HELION">ASICs</a> for AES but not in consumer hardware. The software implementations were highly optimized but still relatively slow compared to applications based on current CPUs supporting AES-NI. The most common optimization trick was using lookup tables to avoid expensive calculations during encryption/decryption. This optimization technique, however, opened the door for an entire set of attacks against those AES implementations. As the lookup tables are typically big enough that they don't fit into a single cache line, cache/timing side-channel attacks became possible. Other possible weaknesses of the software implementations included, of course, human error (speak: security bugs) which may have led to data-dependent timing or completely different attack vectors.</p>
<p>Introducing AES-NI: It is very uncommon, that a piece of software/hardware increases both security and performance. AES-NI is one of those precious pieces of tech. With the tricky bits of AES implemented in hardware (the CPU) and exposed to application and library developers as hardware intrinsics, highly performant and secure AES implementations became a reality. Until recently, those intrinsics were mainly available to C/C++ developers, but with the introduction of hardware intrinsics in .NET Core 3.0 that all changed. The remainder of this blog series will focus on the journey of implementing AES in managed C# code using the AES-NI intrinsics provided in the current .NET Core preview.</p>
<h2>AES key expansion</h2>
<p>Back to the topic at hand. As indicated above, each AES key will be expanded to a 10, 12 or 14 round key schedule for encryption, and another equally sized key schedule for decryption (as AES-NI is based on the Equivalent Inverse Cipher approach described in <a href="https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf" title="NIST FIPS 197">NIST FIPS 197</a>). This key schedule is typically calculated once and ahead of time. This ensures that the cost of the key expansion is amortized over its usage period. Implementations doing the key expansion on the fly are also possible but not profitable unless a minimal amount of blocks are encrypted with each key. To accommodate the key schedule we introduce a class per AES key size containing an array of 4 <code>int</code>s per round key required plus another 4 <code>int</code>s for the original key. The size of this array could be calculated as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>4</mn><mo>∗</mo><mo>(</mo><msub><mi>N</mi><mi>R</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2 * 4 * (N_R + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mbin">∗</span><span class="mord mathrm">4</span><span class="mbin">∗</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> (with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">N_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> as the number of rounds). We can, however, save a few bytes by acknowledging, that the actual key (stored as <code>key[0]</code> in the schedule) is used by both the encryption and decryption algorithm. Furthermore, the last round key for the encryption is reused as the first round key while decrypting.</p>
<p>This leaves us with the following formula to calculate the space required (in <code>int</code>s) for the key schedule: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>4</mn><mo>∗</mo><msub><mi>N</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">2 * 4 * N_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mbin">∗</span><span class="mord mathrm">4</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>.</p>
<h2><code>class</code> vs. <code>readonly ref struct</code></h2>
<p>One design decision was whether a <code>class</code> or a <code>readonly ref struct</code> would be the better home for the key schedule. The advantage of a <code>readonly ref struct</code> is the ability to wrap a <code>Span&lt;T&gt;</code> which would allow keeping the key schedule entirely on the stack (using <code>stackalloc</code>) and avoid heap allocations. There are however many downsides to <code>ref structs</code>:</p>
<ul>
<li>An instance of a key schedule represented as a class can be referred to by many threads.</li>
<li>It is exponentially more convenient for consumers if they can keep a reference to the key (schedule) on the heap if it is used over a prolonged period of time.</li>
<li>Inheritance and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch#type-pattern" title="Type Pattern - C# Language Reference">type patterns</a> (<a href="https://github.com/tkp1n/AesNi/blob/ee982b8fd3a5a9cbfb40af7c30259e286f12e8bb/AesNi/Aes.cs#L67" title="Aes.cs from AesNi">as used here</a>) are the idiomatic way to handle &quot;same but different&quot;-problems in C#. In fact, it even allows keeping the APIs clear of the actual types of keys and to transparently apply the correct AES variant (AES-128, AES-192 or AES-256) to a given problem based on the type of the provided key.</li>
</ul>
<p>With so many arguments in favor of classes, the decision is clear. We must, however, find a way to accommodate for the &quot;brute-force attack&quot; use case from the first post. The current design decision would require us to allocate a new instance of the AES-256 class (including a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>4</mn><mo>∗</mo><mn>1</mn><mn>4</mn></mrow><annotation encoding="application/x-tex">2 * 4 * 14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mbin">∗</span><span class="mord mathrm">4</span><span class="mbin">∗</span><span class="mord mathrm">1</span><span class="mord mathrm">4</span></span></span></span> <code>int</code> array) for every key we would like to try out. Unacceptable. As a work-around to my own design decision, I introduced the instance method <code>ReKey</code> which performs the key expansion for a new input key and stores it in the internal array of the key instance. A dirty trick (breaking the thread safety of the key instances) to improve the performance of the brute-force attack, which I will most likely reconsider in the future.</p>
<h2>Implementation</h2>
<p>The actual implementation of the key expansion revolves around the instruction <code>AESKEYGENASSIST</code> and is provided by <a href="https://www.intel.com/content/dam/doc/white-paper/advanced-encryption-standard-new-instructions-set-paper.pdf" title="AES-NI Paper - Intel">Intels white-paper</a> in figures 24, 25 and 26. It is important to note, that referenced figures of the white-paper only illustrate the key expansion for the encryption half of the key schedule. The decryption key schedule is calculated by applying the instruction <code>AESIMC</code> (IMC = InverseMixColumns) to the round keys <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>N</mi><mi>R</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1..N_R-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> of the encryption key schedule.</p>
<p>Porting the C code provided by Intel to C# is relatively straight forward, but still rather cumbersome. It could be described as the following &quot;algorithm&quot;:</p>
<ul>
<li>Treat all <code>__m128i</code> variables as <code>Vector128&lt;?&gt;</code> (use common sense to determine <code>?</code> in a way that minimizes the need for step 3 below)</li>
<li>For each intrinsic in the C code do:
<ul>
<li>Copy the name of the intrinsic and search for it in the <a href="https://github.com/dotnet/coreclr" title="CoreCLR on GitHub">CoreCLR</a> repository</li>
<li>Find the equivalent name of the C# intrinsic and use it in your C# code</li>
<li>If required, use the <code>AsXYZ()</code> extension methods on the <code>Vector128&lt;?&gt;</code> class to make the type system happy</li>
</ul>
</li>
</ul>
<p>Egor Bogatov is currently busy automating this exact process https://twitter.com/EgorBo/status/1106006223390953473</p>
<h2>Usage</h2>
<p>The entire source is available on my GitHub under the name <a href="https://github.com/tkp1n/AesNi" title="AesNi on GitHub">AesNi</a>. The following snippet showcases the usage of the key expansion as well as the reusability of the <code>key</code> instance using the <code>ReKey</code> method.</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> keyBytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">byte</span></span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// fill with actual key</span><br><span class="token class-name"><span class="token keyword">var</span></span> key <span class="token operator">=</span> AesKey<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>keyBytes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// creates reusable instance of Aes256Key</span><br><br><span class="token comment">// use initial key schedule</span><br>Aes<span class="token punctuation">.</span><span class="token function">Decrypt</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> iv<span class="token punctuation">,</span> key<span class="token punctuation">,</span> CipherMode<span class="token punctuation">.</span>CBC<span class="token punctuation">,</span> PaddingMode<span class="token punctuation">.</span>None<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>keyBytes <span class="token operator">=</span> <span class="token comment">// generate some other key</span><br>key<span class="token punctuation">.</span><span class="token function">ReKey</span><span class="token punctuation">(</span>keyBytes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// performs inplace key expansion</span><br><br><span class="token comment">// use new key schedule</span><br>Aes<span class="token punctuation">.</span><span class="token function">Decrypt</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> iv<span class="token punctuation">,</span> key<span class="token punctuation">,</span> CipherMode<span class="token punctuation">.</span>CBC<span class="token punctuation">,</span> PaddingMode<span class="token punctuation">.</span>None<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2>Performance results</h2>
<p>Creating <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>7</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">17^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">7</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">6</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> <code>ICryptoTransform</code> instances takes 16'318ms (as shown in the last post). The managed AES-NI based implementation introduced in this post requires only 684ms to perform <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>7</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">17^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">7</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">6</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> key expansions. A ~23x improvement!</p>
<p>The next post will introduce the actual encryption and decryption operations using AES-NI in C# and showcase the final performance result of the complete implementation of the brute-force attack using .NET hardware intrinsics.</p>

                </article>
            </main>
        </div>
        <footer>
            <p>&#169; Nicolas Portmann</p>
        </footer>
    </body>
</html>